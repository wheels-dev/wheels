/**
 * Sets or updates environment variables in .env file
 * 
 * Examples:
 * {code:bash}
 * wheels env set DB_HOST=localhost
 * wheels env set DB_PORT=3306 DB_NAME=myapp
 * wheels env set --file=.env.production API_KEY=secret
 * {code}
 */
component extends="commandbox.modules.wheels-cli.commands.wheels.base" {

	// Inject DetailOutputService
	property name="detailOutput" inject="DetailOutputService@wheels-cli";

	/**
	 * @key=value.hint Environment variable(s) to set in KEY=VALUE format
	 * @file.hint The .env file to update (defaults to .env)
	 **/
	function run(
		string file = ".env"
	)
	{
		requireWheelsApp(getCWD());
		arguments = reconstructArgs(argStruct=arguments);
		local.updates = {};

		for (local.key in arguments) {
			// Skip reserved keywords like "file"
			if (local.key != "file") {
				local.updates[local.key] = arguments[local.key];
			}
		}

		if (StructIsEmpty(local.updates)) {
			detailOutput.error("No key=value pairs provided. Usage: wheels env set KEY=VALUE");
		}

		// Update the .env file
		local.envFile = ResolvePath(arguments.file);
		updateEnvFile(local.envFile, local.updates);
	}


	private void function updateEnvFile(required string envFile, required struct updates) {
		local.envContent   = "";
		local.updatedKeys  = [];

		// Read existing .env file (if exists)
		if (FileExists(arguments.envFile)) {
			local.content = FileRead(arguments.envFile);
			
			// Check if it's JSON format
			if (IsJSON(local.content)) {
				local.envData = DeserializeJSON(local.content);

				// Overwrite or add keys
				for (local.key in arguments.updates) {
					local.envData[local.key] = arguments.updates[local.key];
					ArrayAppend(local.updatedKeys, local.key);
				}

				local.envContent = SerializeJSON(local.envData, false, false);
			}
			// Handle key=value (properties) format
			else {
				local.lines         = ListToArray(local.content, Chr(10));
				local.newLines      = [];
				local.processedKeys = {};

				for (local.line in local.lines) {
					local.trimmedLine = Trim(local.line);
					local.lineProcessed = false;
					
					if (Len(local.trimmedLine) && Left(local.trimmedLine, 1) != "##") {
						if (Find("=", local.trimmedLine)) {
							local.lineKey = Trim(ListFirst(local.trimmedLine, "="));
							if (StructKeyExists(arguments.updates, local.lineKey)) {
								// Clean value: remove trailing commas
								local.cleanedValue = ReReplace(arguments.updates[local.lineKey], ",$", "", "all");

								// Overwrite existing key with cleaned value
								ArrayAppend(local.newLines, "#local.lineKey#=#local.cleanedValue#");
								ArrayAppend(local.updatedKeys, local.lineKey);
								local.processedKeys[local.lineKey] = true;
								local.lineProcessed = true;
							}
						}
					}

					// If not overwritten, keep the existing line
					if (!local.lineProcessed) {
						ArrayAppend(local.newLines, local.line);
					}
				}
				
				// Add new keys that weren't in the file
				for (local.key in arguments.updates) {
					if (!StructKeyExists(local.processedKeys, local.key)) {
						ArrayAppend(local.newLines, "#local.key#=#ReReplace(arguments.updates[local.key], ',$', '', 'all')#");
						ArrayAppend(local.updatedKeys, local.key);
					}
				}
				
				local.envContent = ArrayToList(local.newLines, Chr(10));
			}
		}
		// Create new .env file if it doesn't exist
		else {
			local.lines = [
				"## Wheels Environment Configuration",
				"## Generated by wheels env set command",
				""
			];
			
			for (local.key in arguments.updates) {
				ArrayAppend(local.lines, "#local.key#=#ReReplace(arguments.updates[local.key], ',$', '', 'all')#");
				ArrayAppend(local.updatedKeys, local.key);
			}
			
			local.envContent = ArrayToList(local.lines, Chr(10));
		}
		
		// Write the file
		try {
			FileWrite(arguments.envFile, local.envContent);
			
			detailOutput.line();
			detailOutput.statusSuccess("Environment variables updated in #GetFileFromPath(arguments.envFile)#:");

			// Display updated values
			for (local.key in local.updatedKeys) {
				local.displayValue = arguments.updates[local.key];
				// Mask sensitive values
				if (
					FindNoCase("password", local.key) || 
					FindNoCase("secret", local.key)   || 
					FindNoCase("key", local.key)      || 
					FindNoCase("token", local.key)
				) {
					local.displayValue = "***MASKED***";
				}

				detailOutput.metric(local.key, ReReplace(local.displayValue, ',$', '', 'all'));
			}

			// Warn if .env is not in .gitignore
			if (arguments.envFile contains ".env") {
				local.gitignore = ResolvePath(".gitignore");
				if (FileExists(local.gitignore)) {
					local.gitignoreContent = FileRead(local.gitignore);
					if (!FindNoCase(GetFileFromPath(arguments.envFile), local.gitignoreContent)) {
						detailOutput.line();
						detailOutput.statusWarning("#GetFileFromPath(arguments.envFile)# is not in .gitignore!");
						detailOutput.output("Add it to .gitignore to prevent committing secrets.");
					}
				}
			}
			
			// Show next steps
			detailOutput.line();
			detailOutput.statusInfo("Next steps:");
			detailOutput.output("- Restart your application for changes to take effect", true);
			detailOutput.output("- Use 'wheels env show' to view all environment variables", true);
			
		} catch (any e) {
			detailOutput.error("Failed to update .env file: #e.message#");
		}
	}

}