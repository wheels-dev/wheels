/**
 * Sets or updates environment variables in .env file
 * 
 * Examples:
 * {code:bash}
 * wheels env set DB_HOST=localhost
 * wheels env set DB_PORT=3306 DB_NAME=myapp
 * wheels env set --file=.env.production API_KEY=secret
 * {code}
 */
component extends="commandbox.modules.wheels-cli.commands.wheels.base" {

	/**
	 * @key=value.hint Environment variable(s) to set in KEY=VALUE format
	 * @file.hint The .env file to update (defaults to .env)
	 **/
	function run(
		string file = ".env"
	) {

		// Get all key=value pairs from arguments
		local.pairs = [];
		for (local.key in arguments) {
			if (!ListFindNoCase("file", local.key) && Find("=", arguments[local.key])) {
				ArrayAppend(local.pairs, arguments[local.key]);
			}
		}

		// Also check for positional arguments
		if (StructKeyExists(arguments, "1")) {
			local.i = 1;
			while (StructKeyExists(arguments, local.i)) {
				if (Find("=", arguments[local.i])) {
					ArrayAppend(local.pairs, arguments[local.i]);
				}
				local.i++;
			}
		}

		if (ArrayIsEmpty(local.pairs)) {
			error("No key=value pairs provided. Usage: wheels env set KEY=VALUE [KEY2=VALUE2 ...]");
		}

		// Parse key-value pairs
		local.updates = {};
		for (local.pair in local.pairs) {
			local.key = Trim(ListFirst(local.pair, "="));
			local.value = Trim(ListRest(local.pair, "="));
			
			if (!Len(local.key)) {
				error("Invalid format: '#local.pair#'. Use KEY=VALUE format.");
			}
			
			local.updates[local.key] = local.value;
		}

		// Update the .env file
		local.envFile = ResolvePath(arguments.file);
		updateEnvFile(local.envFile, local.updates);
	}

	private void function updateEnvFile(required string envFile, required struct updates) {
		local.envContent = "";
		local.updatedKeys = [];
		
		// Read existing .env file
		if (FileExists(arguments.envFile)) {
			local.content = FileRead(arguments.envFile);
			
			// Check if it's JSON format
			if (IsJSON(local.content)) {
				local.envData = DeserializeJSON(local.content);
				// Update values
				for (local.key in arguments.updates) {
					local.envData[local.key] = arguments.updates[local.key];
					ArrayAppend(local.updatedKeys, local.key);
				}
				local.envContent = SerializeJSON(local.envData, false, false);
			} else {
				// Properties format
				local.lines = ListToArray(local.content, Chr(10));
				local.newLines = [];
				local.processedKeys = {};
				
				for (local.line in local.lines) {
					local.trimmedLine = Trim(local.line);
					local.lineProcessed = false;
					
					if (Len(local.trimmedLine) && Left(local.trimmedLine, 1) != "##") {
						if (Find("=", local.trimmedLine)) {
							local.lineKey = Trim(ListFirst(local.trimmedLine, "="));
							if (StructKeyExists(arguments.updates, local.lineKey)) {
								// Update existing key
								ArrayAppend(local.newLines, "#local.lineKey#=#arguments.updates[local.lineKey]#");
								ArrayAppend(local.updatedKeys, local.lineKey);
								local.processedKeys[local.lineKey] = true;
								local.lineProcessed = true;
							}
						}
					}
					
					if (!local.lineProcessed) {
						ArrayAppend(local.newLines, local.line);
					}
				}
				
				// Add new keys that weren't in the file
				for (local.key in arguments.updates) {
					if (!StructKeyExists(local.processedKeys, local.key)) {
						ArrayAppend(local.newLines, "#local.key#=#arguments.updates[local.key]#");
						ArrayAppend(local.updatedKeys, local.key);
					}
				}
				
				local.envContent = ArrayToList(local.newLines, Chr(10));
			}
		} else {
			// Create new .env file
			local.lines = [
				"## Wheels Environment Configuration",
				"## Generated by wheels env set command",
				""
			];
			
			for (local.key in arguments.updates) {
				ArrayAppend(local.lines, "#local.key#=#arguments.updates[local.key]#");
				ArrayAppend(local.updatedKeys, local.key);
			}
			
			local.envContent = ArrayToList(local.lines, Chr(10));
		}
		
		// Write the file
		try {
			FileWrite(arguments.envFile, local.envContent);
			
			print.line();
			print.greenLine("✓ Environment variables updated in #GetFileFromPath(arguments.envFile)#:");
			for (local.key in local.updatedKeys) {
				local.displayValue = arguments.updates[local.key];
				// Mask sensitive values
				if (FindNoCase("password", local.key) || FindNoCase("secret", local.key) || 
					FindNoCase("key", local.key) || FindNoCase("token", local.key)) {
					local.displayValue = "***MASKED***";
				}
				print.line("  #local.key# = #local.displayValue#");
			}
			
			// Check if .env is in .gitignore
			if (arguments.envFile contains ".env") {
				local.gitignore = ResolvePath(".gitignore");
				if (FileExists(local.gitignore)) {
					local.gitignoreContent = FileRead(local.gitignore);
					if (!FindNoCase(GetFileFromPath(arguments.envFile), local.gitignoreContent)) {
						print.line();
						print.yellowLine("⚠ Warning: #GetFileFromPath(arguments.envFile)# is not in .gitignore!");
						print.line("  Add it to .gitignore to prevent committing secrets");
					}
				}
			}
		} catch (any e) {
			error("Failed to update .env file: #e.message#");
		}
	}

}