# /wheels_build - Implement From Specification

## Description
Implement a Wheels application feature from an approved specification. Builds components in the correct order with incremental testing after each step.

## Usage
```
/wheels_build                    # Build from latest spec (.specs/current.md)
/wheels_build [spec-filename]    # Build from a specific spec file
```

## Examples
```
/wheels_build
/wheels_build 20250930-163000-blog-posts-comments.md
```

## Prerequisites

- An approved spec must exist in `.specs/` (generated by `/wheels_spec`)
- If no spec exists, tell the user to run `/wheels_spec` first

## Workflow

### Step 0: Load the Spec

Read the approved specification:
```
Read(".specs/current.md")
```
Or if a specific filename was given:
```
Read(".specs/[filename]")
```

Verify the spec has `**Status:** approved`. If status is `completed`, warn the user this spec was already built and ask if they want to rebuild.

Update the spec status:
```
Edit: **Status:** approved  ->  **Status:** in-progress
```

### Step 1: Detect Available Tools

Check if MCP tools are available:
```
ls .mcp.json
```

If `.mcp.json` exists:
- Use `mcp__wheels__wheels_generate()` for code generation
- Use `mcp__wheels__wheels_migrate()` for migrations
- Use `mcp__wheels__wheels_test()` for tests
- Use `mcp__wheels__wheels_reload()` for app reload
- Use `mcp__wheels__wheels_server(action="status")` to get the server port

If `.mcp.json` does not exist:
- Use CLI commands (`wheels g model`, `wheels dbmigrate`, `wheels test run`)
- Read `server.json` for port, default to 8080

Store the base URL (e.g., `http://localhost:PORT`) for testing throughout.

### Step 2: Create Task List

Break the spec into granular tasks using TaskCreate. Follow this exact build order:

1. **Migrations** (database tables must exist before models reference them)
2. **Models** (models must exist before controllers use them)
3. **Controllers** (controllers must exist before views reference actions)
4. **Views** (layout first, then individual views)
5. **Routes** (configure after controllers/views exist)
6. **Tests** (verify everything works)

Create one task per:
- Migration file
- Model file
- Controller file
- View file (each view is its own task)
- Route configuration change
- Test suite

### Step 3: Build Migrations

For each migration in the spec:

1. Mark the task as `in_progress`
2. Generate the migration file

**If using MCP:**
```
mcp__wheels__wheels_generate(type="migration", name="CreatePostsTable", attributes="...")
```

**If using CLI:**
```
wheels g migration CreatePostsTable
```

3. After generation, read the migration file and fix known issues:

**Fix string boolean values** (CLI generators produce these):
```cfm
BAD:  createTable(name='posts', force='false', id='true')
GOOD: createTable(name='posts')
```

**Fix database-specific SQL in seed data**:
```cfm
BAD:  DATE_SUB(NOW(), INTERVAL 1 DAY)
GOOD: TIMESTAMP '#DateFormat(DateAdd("d", -1, Now()), "yyyy-mm-dd")# #TimeFormat(DateAdd("d", -1, Now()), "HH:mm:ss")#'
```

4. Run the migration:
```
mcp__wheels__wheels_migrate(action="latest")    # MCP
wheels dbmigrate latest                          # CLI
```

5. Verify migrations ran successfully (check output for errors)
6. Mark the task as `completed`

### Step 4: Build Models

For each model in the spec:

1. Mark the task as `in_progress`
2. Generate the model:
```
mcp__wheels__wheels_generate(type="model", name="Post", attributes="title:string,content:text")
```
3. Read the generated file and enhance it with the spec's requirements:
   - Add associations with **all named parameters** (never mix positional and named)
   - Add validations
   - Add callbacks
   - Add custom methods

**Critical: Use the wheels-codegen skill patterns.** Key rules:
```cfm
// ALWAYS use all-named parameters when adding extra options:
hasMany(name="comments", dependent="delete")     // Correct
belongsTo(name="post")                            // Correct
hasMany("comments")                               // Correct (all positional, no extras)

// NEVER mix positional and named:
hasMany("comments", dependent="delete")           // WRONG
```

4. Reload the app and verify no errors:
```bash
curl -s http://localhost:PORT/?reload=true -I    # Should return 200
```
5. Mark the task as `completed`

### Step 5: Build Controllers

For each controller in the spec:

1. Mark the task as `in_progress`
2. Generate the controller:
```
mcp__wheels__wheels_generate(type="controller", name="Posts", actions="index,show,new,create,edit,update,delete")
```
3. Read the generated file and enhance per the spec:
   - Add `config()` with filters and verifies
   - Implement each action per the spec
   - Add private filter functions (filters MUST be private)
   - Add flash messages for create/update/delete
   - Handle validation failures (renderView back to form)

**Key controller patterns:**
```cfm
// Filter functions MUST be private
private function findPost() {
    post = model("Post").findByKey(key=params.key);
    if (!isObject(post)) {
        flashInsert(error="Post not found.");
        redirectTo(action="index");
    }
}

// Create action pattern
function create() {
    post = model("Post").new(params.post);
    if (post.save()) {
        flashInsert(success="Post created!");
        redirectTo(action="show", key=post.id);
    } else {
        flashInsert(error="Please fix the errors below.");
        renderView(action="new");
    }
}
```

4. Reload and test that controller actions respond:
```bash
curl -s http://localhost:PORT/posts -I    # Should return 200 or redirect
```
5. Mark the task as `completed`

### Step 6: Build Views

Build views in this order: layout first, then index, show, new, edit.

**Layout (if needed):**
1. Create `app/views/layout.cfm` with the spec's frontend stack
2. Include: `csrfMetaTags()`, `styleSheetLinkTag()`, `flashMessages()`, `includeContent()`, `javaScriptIncludeTag()`
3. Test: reload and hit homepage, verify no 500 error

**For each view:**

1. Mark the task as `in_progress`
2. Create the view file per the spec
3. Every view MUST start with `cfparam` declarations for its data dependencies:
```cfm
<cfparam name="posts">          <!--- for index views --->
<cfparam name="post">           <!--- for show/edit views --->
```

4. **Critical view patterns to follow:**

**Index views - query loops:**
```cfm
<cfloop query="posts">
    <h2>#posts.title#</h2>       <!--- Access columns via query name --->
</cfloop>
```

**Show views - association access:**
```cfm
<!--- Load association data in controller and pass as variable --->
<!--- In controller: comments = post.comments(order="createdAt DESC") --->
<cfparam name="comments">
<cfloop query="comments">
    <p>#comments.content#</p>
</cfloop>
```

**Form views - validation errors:**
```cfm
#textField(objectName="post", property="title", label=false)#
<cfif post.hasErrors("title")>
    <p class="text-red-600 text-sm">#post.allErrors("title")[1].message#</p>
</cfif>
```

**Form views - CSRF protection:**
```cfm
#startFormTag(controller="posts", action="create", method="post")#
    <!--- Wheels form helpers include CSRF automatically when protectsFromForgery() is set --->
    <!--- fields here --->
    #submitTag(value="Save")#
#endFormTag()#
```

5. Test IMMEDIATELY after creating each view:
```bash
# Check HTTP status
curl -s http://localhost:PORT/posts -I           # 200?
# Check content renders
curl -s http://localhost:PORT/posts | grep "expected text"
```

6. If the view returns 500, read the error output and fix before moving on
7. Mark the task as `completed`

**Key rule: Never start the next view until the current one works.**

### Step 7: Configure Routes

1. Mark the task as `in_progress`
2. Read `config/routes.cfm`
3. Add/modify routes per the spec

**Route ordering matters:**
```cfm
mapper()
    // 1. Resource routes first
    .resources("posts")
    .resources("comments")

    // 2. Root route
    .root(to="posts##index", method="get")

    // 3. Wildcard last
    .wildcard()
.end();
```

4. Reload the app
5. Test that URLs resolve:
```bash
curl -s http://localhost:PORT/ -I               # Root
curl -s http://localhost:PORT/posts -I           # Index
curl -s http://localhost:PORT/posts/1 -I         # Show
curl -s http://localhost:PORT/posts/new -I       # New form
```
6. Mark the task as `completed`

### Step 8: Run Tests

1. Mark the task as `in_progress`
2. Run the test suite:
```
mcp__wheels__wheels_test()    # MCP
wheels test run                # CLI
```
3. If tests fail, read failures and fix the issues
4. Re-run until all tests pass
5. Mark the task as `completed`

### Step 9: Final Verification

Do a quick end-to-end check:
- Hit each major URL and verify 200 status
- Verify content appears (not just status code)
- Check that the frontend stack loads (CSS/JS)
- Verify forms have fields, labels, and submit buttons

### Step 10: Update the Spec

Mark the spec as completed:
```
Edit: **Status:** in-progress  ->  **Status:** completed
```

Add a "Files Created" section listing all files that were created or modified.

### Step 11: Report Results

Present a summary:
- What was built (list of components)
- Test results (pass/fail)
- URLs to visit
- Files created/modified
- Any issues encountered and how they were resolved

Tell the user:
```
Implementation complete. Run /wheels_validate for a thorough verification.
```

## Error Recovery

If a step fails:

1. **Do not skip it.** Fix the issue before moving to the next step.
2. **Read error output carefully.** Wheels error pages contain useful details.
3. **Check for common causes:**
   - Mixed argument styles in model associations
   - Missing `cfparam` in views
   - Forgotten `private` keyword on filter functions
   - String boolean values in migrations
   - Database-specific SQL in seed data
4. **If stuck after 2 attempts**, report what failed and ask the user for guidance.

## Build Without a Spec

If the user runs `/wheels_build` with no spec file:
1. Check `.specs/current.md` - if it exists and is approved, use it
2. If no spec exists, tell the user:
```
No approved specification found. Run /wheels_spec first to create one,
or describe what you want to build and I will create a spec for you.
```

## Integration with Other Commands

- **Input**: Reads `.specs/*.md` files generated by `/wheels_spec`
- **Uses**: Skills for code generation patterns (wheels-codegen, wheels-testing, wheels-scaffold)
- **Output**: A working implementation ready for `/wheels_validate`
