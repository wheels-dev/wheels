{
  "accessibleProperties": {
    "prefix": "accessibleProperties",
    "description": "Use this method inside your model’s config() function to whitelist which properties can be set via mass assignment operations (such as updateAll(), updateOne() and etc). This helps protect your model from accidental or malicious updates to sensitive fields (e.g., isAdmin, passwordHash, etc.).",
    "body": [
      "accessibleProperties()$0"
    ],
    "scope": "cfml"
  },
  "accessibleProperties(allParams)": {
    "prefix": "accessibleProperties",
    "description": "Use this method inside your model’s config() function to whitelist which properties can be set via mass assignment operations (such as updateAll(), updateOne() and etc). This helps protect your model from accidental or malicious updates to sensitive fields (e.g., isAdmin, passwordHash, etc.).",
    "body": [
      "accessibleProperties(properties = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "addColumn": {
    "prefix": "addColumn",
    "description": "Adds a new column to an existing table.\n This function is only available inside a migration CFC and is part of the Wheels migrator API. Use it to evolve your database schema safely through versioned migrations.",
    "body": [
      "addColumn(table = ${1:\"\"}, columnType = ${2:\"\"}, columnName = ${3:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "addColumn(allParams)": {
    "prefix": "addColumn",
    "description": "Adds a new column to an existing table.\n This function is only available inside a migration CFC and is part of the Wheels migrator API. Use it to evolve your database schema safely through versioned migrations.",
    "body": [
      "addColumn(table = ${1:\"\"}, columnType = ${2:\"\"}, columnName = ${3:\"\"}, afterColumn = ${4:\"\"}, referenceName = ${5:\"\"}, default = ${6:\"\"}, allowNull = ${7:\"\"}, limit = ${8:\"\"}, precision = ${9:\"\"}, scale = ${10:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "addError": {
    "prefix": "addError",
    "description": "Adds a custom error to a model instance. This is useful when built-in validations don’t fully cover your business rules, or when you want to enforce conditional logic. The error will be attached to the given property and can later be retrieved using functions like errorsOn() or allErrors().",
    "body": [
      "addError(property = ${1:\"\"}, message = ${2:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "addError(allParams)": {
    "prefix": "addError",
    "description": "Adds a custom error to a model instance. This is useful when built-in validations don’t fully cover your business rules, or when you want to enforce conditional logic. The error will be attached to the given property and can later be retrieved using functions like errorsOn() or allErrors().",
    "body": [
      "addError(property = ${1:\"\"}, message = ${2:\"\"}, name = ${3:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "addErrorToBase": {
    "prefix": "addErrorToBase",
    "description": "Adds an error directly on the model object itself, not tied to a specific property. This is useful when the error applies to the object as a whole or to a combination of properties, rather than a single field (for example: comparing two values, enforcing cross-property business rules, or validating external conditions).",
    "body": [
      "addErrorToBase(message = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "addErrorToBase(allParams)": {
    "prefix": "addErrorToBase",
    "description": "Adds an error directly on the model object itself, not tied to a specific property. This is useful when the error applies to the object as a whole or to a combination of properties, rather than a single field (for example: comparing two values, enforcing cross-property business rules, or validating external conditions).",
    "body": [
      "addErrorToBase(message = ${1:\"\"}, name = ${2:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "addForeignKey": {
    "prefix": "addForeignKey",
    "description": "Adds a foreign key constraint between two tables. This ensures that values in one table’s column must exist in the referenced column of another table, enforcing referential integrity. This function is only available inside a migration CFC and is part of the Wheels migrator API.",
    "body": [
      "addForeignKey(table = ${1:\"\"}, referenceTable = ${2:\"\"}, column = ${3:\"\"}, referenceColumn = ${4:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "addFormat": {
    "prefix": "addFormat",
    "description": "Registers a new MIME type in your Wheels application for use with responding to multiple formats. This is helpful when your app needs to handle file types beyond the defaults provided by Wheels (e.g., serving JavaScript, PowerPoint, JSON, custom data formats).",
    "body": [
      "addFormat(extension = ${1:\"\"}, mimeType = ${2:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "addIndex": {
    "prefix": "addIndex",
    "description": "Adds a database index on one or more columns of a table. Indexes speed up queries that filter, sort, or join on those columns. This function is only available inside a migration CFC and is part of the Wheels migrator API.",
    "body": [
      "addIndex(table = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "addIndex(allParams)": {
    "prefix": "addIndex",
    "description": "Adds a database index on one or more columns of a table. Indexes speed up queries that filter, sort, or join on those columns. This function is only available inside a migration CFC and is part of the Wheels migrator API.",
    "body": [
      "addIndex(table = ${1:\"\"}, columnNames = ${2:\"\"}, unique = ${3:\"false\"}, indexName = ${4:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "addRecord": {
    "prefix": "addRecord",
    "description": "Inserts a new record into a table. This function is only available inside a migration CFC and is part of the Wheels migrator API. Useful for seeding initial data (like admin users, roles, or lookup values) alongside schema changes.",
    "body": [
      "addRecord(table = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "addReference": {
    "prefix": "addReference",
    "description": "Adds a reference column and a foreign key constraint to a table in one step. This is a shortcut for creating an integer column (e.g., userId) and then linking it to another table using a foreign key. This function is only available inside a migration CFC and is part of the Wheels migrator API.",
    "body": [
      "addReference(table = ${1:\"\"}, referenceName = ${2:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "afterCreate": {
    "prefix": "afterCreate",
    "description": "Registers one or more callback methods that are automatically executed after a new object is created (i.e., after calling create() on a model). This is part of the model lifecycle callbacks in Wheels.",
    "body": [
      "afterCreate()$0"
    ],
    "scope": "cfml"
  },
  "afterCreate(allParams)": {
    "prefix": "afterCreate",
    "description": "Registers one or more callback methods that are automatically executed after a new object is created (i.e., after calling create() on a model). This is part of the model lifecycle callbacks in Wheels.",
    "body": [
      "afterCreate(methods = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "afterDelete": {
    "prefix": "afterDelete",
    "description": "Registers one or more callback methods that should be executed after an object is deleted from the database. This hook allows you to perform cleanup, logging, or side effects when a record has been removed.",
    "body": [
      "afterDelete()$0"
    ],
    "scope": "cfml"
  },
  "afterDelete(allParams)": {
    "prefix": "afterDelete",
    "description": "Registers one or more callback methods that should be executed after an object is deleted from the database. This hook allows you to perform cleanup, logging, or side effects when a record has been removed.",
    "body": [
      "afterDelete(methods = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "afterFind": {
    "prefix": "afterFind",
    "description": "Registers one or more callback methods that should be executed after an existing object has been initialized, typically via finder methods such as findByKey, findOne, findAll, or other query-based lookups. This hook is useful for adjusting, enriching, or transforming model objects immediately after they are loaded from the database.",
    "body": [
      "afterFind()$0"
    ],
    "scope": "cfml"
  },
  "afterFind(allParams)": {
    "prefix": "afterFind",
    "description": "Registers one or more callback methods that should be executed after an existing object has been initialized, typically via finder methods such as findByKey, findOne, findAll, or other query-based lookups. This hook is useful for adjusting, enriching, or transforming model objects immediately after they are loaded from the database.",
    "body": [
      "afterFind(methods = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "afterInitialization": {
    "prefix": "afterInitialization",
    "description": "Registers one or more callback methods that should be executed after an object has been initialized. Initialization happens in two cases, When a new object is created (via new() or similar) or when an existing object is fetched from the database (via findByKey, findOne, etc.). This makes afterInitialization() more general than afterCreate() or afterFind(), since it runs in both scenarios.",
    "body": [
      "afterInitialization()$0"
    ],
    "scope": "cfml"
  },
  "afterInitialization(allParams)": {
    "prefix": "afterInitialization",
    "description": "Registers one or more callback methods that should be executed after an object has been initialized. Initialization happens in two cases, When a new object is created (via new() or similar) or when an existing object is fetched from the database (via findByKey, findOne, etc.). This makes afterInitialization() more general than afterCreate() or afterFind(), since it runs in both scenarios.",
    "body": [
      "afterInitialization(methods = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "afterNew": {
    "prefix": "afterNew",
    "description": "Registers one or more callback methods that should be executed after a new object has been initialized, typically via the new() method. This hook is useful for setting default values, preparing derived attributes, or running logic every time you create a fresh model instance (before saving it to the database).",
    "body": [
      "afterNew()$0"
    ],
    "scope": "cfml"
  },
  "afterNew(allParams)": {
    "prefix": "afterNew",
    "description": "Registers one or more callback methods that should be executed after a new object has been initialized, typically via the new() method. This hook is useful for setting default values, preparing derived attributes, or running logic every time you create a fresh model instance (before saving it to the database).",
    "body": [
      "afterNew(methods = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "afterSave": {
    "prefix": "afterSave",
    "description": "Registers one or more callback methods that should be executed after an object is saved to the database. This hook runs whether the save was the result of creating a new record or updating an existing one. It’s ideal for tasks that must happen after persistence, such as logging, syncing data, or triggering external processes.",
    "body": [
      "afterSave()$0"
    ],
    "scope": "cfml"
  },
  "afterSave(allParams)": {
    "prefix": "afterSave",
    "description": "Registers one or more callback methods that should be executed after an object is saved to the database. This hook runs whether the save was the result of creating a new record or updating an existing one. It’s ideal for tasks that must happen after persistence, such as logging, syncing data, or triggering external processes.",
    "body": [
      "afterSave(methods = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "afterUpdate": {
    "prefix": "afterUpdate",
    "description": "Registers one or more callback methods that should be executed after an existing object has been updated in the database. This hook is ideal for performing follow-up tasks whenever a record changes — such as logging, cache invalidation, or sending notifications about updates.",
    "body": [
      "afterUpdate()$0"
    ],
    "scope": "cfml"
  },
  "afterUpdate(allParams)": {
    "prefix": "afterUpdate",
    "description": "Registers one or more callback methods that should be executed after an existing object has been updated in the database. This hook is ideal for performing follow-up tasks whenever a record changes — such as logging, cache invalidation, or sending notifications about updates.",
    "body": [
      "afterUpdate(methods = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "afterValidation": {
    "prefix": "afterValidation",
    "description": "Registers one or more callback methods that should be executed after an object has been validated. This hook is useful for running extra logic that depends on validation results, such as adjusting error messages, performing side validations, or preparing data before saving.",
    "body": [
      "afterValidation()$0"
    ],
    "scope": "cfml"
  },
  "afterValidation(allParams)": {
    "prefix": "afterValidation",
    "description": "Registers one or more callback methods that should be executed after an object has been validated. This hook is useful for running extra logic that depends on validation results, such as adjusting error messages, performing side validations, or preparing data before saving.",
    "body": [
      "afterValidation(methods = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "afterValidationOnCreate": {
    "prefix": "afterValidationOnCreate",
    "description": "Registers one or more callback methods that should be executed after a new object has been validated (i.e., when running validations during a create() or save() on a new record). This hook is useful when you want to apply custom logic only during new record creation, not during updates.",
    "body": [
      "afterValidationOnCreate()$0"
    ],
    "scope": "cfml"
  },
  "afterValidationOnCreate(allParams)": {
    "prefix": "afterValidationOnCreate",
    "description": "Registers one or more callback methods that should be executed after a new object has been validated (i.e., when running validations during a create() or save() on a new record). This hook is useful when you want to apply custom logic only during new record creation, not during updates.",
    "body": [
      "afterValidationOnCreate(methods = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "afterValidationOnUpdate": {
    "prefix": "afterValidationOnUpdate",
    "description": "Registers one or more callback methods that should be executed after an existing object has been validated (i.e., when running validations during an update() or save() on an already-persisted record). This hook is useful when you want logic to run only on updates, not on initial creation.",
    "body": [
      "afterValidationOnUpdate()$0"
    ],
    "scope": "cfml"
  },
  "afterValidationOnUpdate(allParams)": {
    "prefix": "afterValidationOnUpdate",
    "description": "Registers one or more callback methods that should be executed after an existing object has been validated (i.e., when running validations during an update() or save() on an already-persisted record). This hook is useful when you want logic to run only on updates, not on initial creation.",
    "body": [
      "afterValidationOnUpdate(methods = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "allChanges": {
    "prefix": "allChanges",
    "description": "Returns a struct containing all unsaved changes made to an object since it was last loaded or saved. Each entry in the struct uses the property name as the key and the new (unsaved) value as the value.",
    "body": [
      "allChanges()$0"
    ],
    "scope": "cfml"
  },
  "allErrors": {
    "prefix": "allErrors",
    "description": "Returns an array of all the errors on the object.\n\n\nIt does this by storing instances of models that are associations, and not checking associations of those instances because they have already been checked.",
    "body": [
      "allErrors()$0"
    ],
    "scope": "cfml"
  },
  "allErrors(allParams)": {
    "prefix": "allErrors",
    "description": "Returns an array of all the errors on the object.\n\n\nIt does this by storing instances of models that are associations, and not checking associations of those instances because they have already been checked.",
    "body": [
      "allErrors(includeAssociations = ${1:\"\"}, seenErrors = ${2:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "announce": {
    "prefix": "announce",
    "description": "Outputs a custom message during migration execution. This is useful for logging progress or providing context when multiple migration steps are running.",
    "body": [
      "announce(message = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "assert": {
    "prefix": "assert",
    "description": "Asserts that an expression evaluates to true in a test. If the expression evaluates to false, the test will fail and an error will be raised. This is one of the core testing functions available when writing legacy tests in Wheels.",
    "body": [
      "assert(expression = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "authenticityToken": {
    "prefix": "authenticityToken",
    "description": "Returns the raw CSRF authenticity token for the current user session. This token is used to help protect against Cross-Site Request Forgery (CSRF) attacks by verifying that form submissions or AJAX requests originate from your application. You typically won’t call this function directly in views — instead, Wheels provides helpers like authenticityTokenField() to generate hidden form fields. But authenticityToken() can be useful if you need direct access to the token string (for example, in custom JavaScript code).",
    "body": [
      "authenticityToken()$0"
    ],
    "scope": "cfml"
  },
  "authenticityTokenField": {
    "prefix": "authenticityTokenField",
    "description": "Generates a hidden form field that contains a CSRF authenticity token. This token is required for verifying that POST, PUT, PATCH, or DELETE requests originated from your application, helping protect against Cross-Site Request Forgery (CSRF) attacks. When you use startFormTag(), Wheels automatically includes the token field for you. You’ll usually only need to call authenticityTokenField() manually when creating forms without startFormTag() or when building raw HTML forms.",
    "body": [
      "authenticityTokenField()$0"
    ],
    "scope": "cfml"
  },
  "autoLink": {
    "prefix": "autoLink",
    "description": "Scans a block of text for URLs and/or email addresses and automatically converts them into clickable links. This helper is handy for displaying user-generated content, comments, or messages where you want to make links interactive without manually adding <a> tags.",
    "body": [
      "autoLink(text = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "autoLink(allParams)": {
    "prefix": "autoLink",
    "description": "Scans a block of text for URLs and/or email addresses and automatically converts them into clickable links. This helper is handy for displaying user-generated content, comments, or messages where you want to make links interactive without manually adding <a> tags.",
    "body": [
      "autoLink(text = ${1:\"\"}, link = ${2:\"all\"}, relative = ${3:\"True\"}, encode = ${4:\"True\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "automaticValidations": {
    "prefix": "automaticValidations",
    "description": "Controls whether automatic validations should be enabled for a specific model. By default, Wheels can automatically infer validations from your database schema (e.g., NOT NULL fields, field length limits, etc.). This function lets you override that behavior at the model level — enabling or disabling automatic validations regardless of the global setting.",
    "body": [
      "automaticValidations(value = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "average": {
    "prefix": "average",
    "description": "Calculates the average value for a given property.\nUses the SQL function <code>AVG</code>.\nIf no records can be found to perform the calculation on you can use the <code>ifNull</code> argument to decide what should be returned.",
    "body": [
      "average(property = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "average(allParams)": {
    "prefix": "average",
    "description": "Calculates the average value for a given property.\nUses the SQL function <code>AVG</code>.\nIf no records can be found to perform the calculation on you can use the <code>ifNull</code> argument to decide what should be returned.",
    "body": [
      "average(property = ${1:\"\"}, where = ${2:\"\"}, include = ${3:\"\"}, distinct = ${4:\"\"}, parameterize = ${5:\"True\"}, ifNull = ${6:\"\"}, includeSoftDeletes = ${7:\"false\"}, group = ${8:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "beforeCreate": {
    "prefix": "beforeCreate",
    "description": "Registers method(s) that should be called before a new object is created. This allows you to modify or validate data, set defaults, or perform logic right before the object is persisted in the database for the first time.",
    "body": [
      "beforeCreate()$0"
    ],
    "scope": "cfml"
  },
  "beforeCreate(allParams)": {
    "prefix": "beforeCreate",
    "description": "Registers method(s) that should be called before a new object is created. This allows you to modify or validate data, set defaults, or perform logic right before the object is persisted in the database for the first time.",
    "body": [
      "beforeCreate(methods = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "beforeDelete": {
    "prefix": "beforeDelete",
    "description": "Registers method(s) that should be called before an object is deleted. This allows you to perform cleanup, enforce constraints, or prevent deletion if certain conditions are not met.",
    "body": [
      "beforeDelete()$0"
    ],
    "scope": "cfml"
  },
  "beforeDelete(allParams)": {
    "prefix": "beforeDelete",
    "description": "Registers method(s) that should be called before an object is deleted. This allows you to perform cleanup, enforce constraints, or prevent deletion if certain conditions are not met.",
    "body": [
      "beforeDelete(methods = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "beforeSave": {
    "prefix": "beforeSave",
    "description": "Registers method(s) that should be called before an object is saved. This is useful for performing transformations, validations, or logging before data is persisted.",
    "body": [
      "beforeSave()$0"
    ],
    "scope": "cfml"
  },
  "beforeSave(allParams)": {
    "prefix": "beforeSave",
    "description": "Registers method(s) that should be called before an object is saved. This is useful for performing transformations, validations, or logging before data is persisted.",
    "body": [
      "beforeSave(methods = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "beforeUpdate": {
    "prefix": "beforeUpdate",
    "description": "Registers method(s) that should be called before an existing object is updated. This is useful for enforcing rules, transforming values, or checking conditions specifically for update operations (unlike beforeSave(), which applies to both create and update).",
    "body": [
      "beforeUpdate()$0"
    ],
    "scope": "cfml"
  },
  "beforeUpdate(allParams)": {
    "prefix": "beforeUpdate",
    "description": "Registers method(s) that should be called before an existing object is updated. This is useful for enforcing rules, transforming values, or checking conditions specifically for update operations (unlike beforeSave(), which applies to both create and update).",
    "body": [
      "beforeUpdate(methods = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "beforeValidation": {
    "prefix": "beforeValidation",
    "description": "Registers method(s) that should be called before an object is validated. This hook is helpful when you want to adjust, normalize, or clean up data before validation rules run. It ensures the object is in the correct state so that validations pass or fail as expected.",
    "body": [
      "beforeValidation()$0"
    ],
    "scope": "cfml"
  },
  "beforeValidation(allParams)": {
    "prefix": "beforeValidation",
    "description": "Registers method(s) that should be called before an object is validated. This hook is helpful when you want to adjust, normalize, or clean up data before validation rules run. It ensures the object is in the correct state so that validations pass or fail as expected.",
    "body": [
      "beforeValidation(methods = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "beforeValidationOnCreate": {
    "prefix": "beforeValidationOnCreate",
    "description": "Registers method(s) that should be called before a new object is validated. This hook is useful when you want to prepare or sanitize data specifically for new records, ensuring that validations run on properly formatted data. It will not run on updates—only on create() or new() + save() operations.",
    "body": [
      "beforeValidationOnCreate()$0"
    ],
    "scope": "cfml"
  },
  "beforeValidationOnCreate(allParams)": {
    "prefix": "beforeValidationOnCreate",
    "description": "Registers method(s) that should be called before a new object is validated. This hook is useful when you want to prepare or sanitize data specifically for new records, ensuring that validations run on properly formatted data. It will not run on updates—only on create() or new() + save() operations.",
    "body": [
      "beforeValidationOnCreate(methods = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "beforeValidationOnUpdate": {
    "prefix": "beforeValidationOnUpdate",
    "description": "Registers method(s) that should be called before an existing object is validated. This hook is useful when you want to adjust, sanitize, or enforce rules specifically for updates (not for new records). It ensures the object is in the correct state before validation checks run.",
    "body": [
      "beforeValidationOnUpdate()$0"
    ],
    "scope": "cfml"
  },
  "beforeValidationOnUpdate(allParams)": {
    "prefix": "beforeValidationOnUpdate",
    "description": "Registers method(s) that should be called before an existing object is validated. This hook is useful when you want to adjust, sanitize, or enforce rules specifically for updates (not for new records). It ensures the object is in the correct state before validation checks run.",
    "body": [
      "beforeValidationOnUpdate(methods = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "belongsTo": {
    "prefix": "belongsTo",
    "description": "Sets up a belongsTo association between this model and another model. Use this when the current model contains a foreign key referencing another model. This establishes a one-to-many relationship from the perspective of the other model (i.e., this model “belongs to” a parent model).",
    "body": [
      "belongsTo(name = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "belongsTo(allParams)": {
    "prefix": "belongsTo",
    "description": "Sets up a belongsTo association between this model and another model. Use this when the current model contains a foreign key referencing another model. This establishes a one-to-many relationship from the perspective of the other model (i.e., this model “belongs to” a parent model).",
    "body": [
      "belongsTo(name = ${1:\"\"}, modelName = ${2:\"\"}, foreignKey = ${3:\"\"}, joinKey = ${4:\"\"}, joinType = ${5:\"inner\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "bigInteger": {
    "prefix": "bigInteger",
    "description": "Adds one or more big integer columns to a table definition in a migration. Use this when you need columns capable of storing large integer values, typically larger than standard integer columns.",
    "body": [
      "bigInteger()$0"
    ],
    "scope": "cfml"
  },
  "bigInteger(allParams)": {
    "prefix": "bigInteger",
    "description": "Adds one or more big integer columns to a table definition in a migration. Use this when you need columns capable of storing large integer values, typically larger than standard integer columns.",
    "body": [
      "bigInteger(columnNames = ${1:\"\"}, limit = ${2:\"\"}, default = ${3:\"\"}, allowNull = ${4:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "binary": {
    "prefix": "binary",
    "description": "Adds one or more binary columns to a table definition in a migration. Use this for storing raw binary data, such as files, images, or other byte streams.",
    "body": [
      "binary()$0"
    ],
    "scope": "cfml"
  },
  "binary(allParams)": {
    "prefix": "binary",
    "description": "Adds one or more binary columns to a table definition in a migration. Use this for storing raw binary data, such as files, images, or other byte streams.",
    "body": [
      "binary(columnNames = ${1:\"\"}, default = ${2:\"\"}, allowNull = ${3:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "boolean": {
    "prefix": "boolean",
    "description": "Adds one or more boolean columns to a table definition in a migration. Use this for columns that store true/false values.",
    "body": [
      "boolean()$0"
    ],
    "scope": "cfml"
  },
  "boolean(allParams)": {
    "prefix": "boolean",
    "description": "Adds one or more boolean columns to a table definition in a migration. Use this for columns that store true/false values.",
    "body": [
      "boolean(columnNames = ${1:\"\"}, default = ${2:\"\"}, allowNull = ${3:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "buttonTag": {
    "prefix": "buttonTag",
    "description": "Builds and returns a string containing a button form control for use in your HTML forms. Use this helper to create buttons with custom content, types, values, images, and optional HTML wrappers.",
    "body": [
      "buttonTag()$0"
    ],
    "scope": "cfml"
  },
  "buttonTag(allParams)": {
    "prefix": "buttonTag",
    "description": "Builds and returns a string containing a button form control for use in your HTML forms. Use this helper to create buttons with custom content, types, values, images, and optional HTML wrappers.",
    "body": [
      "buttonTag(content = ${1:\"Save changes\"}, type = ${2:\"submit\"}, value = ${3:\"save\"}, image = ${4:\"\"}, prepend = ${5:\"\"}, append = ${6:\"\"}, encode = ${7:\"True\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "buttonTo": {
    "prefix": "buttonTo",
    "description": "Creates a form containing a single button that submits to a URL. The URL is constructed the same way as linkTo(). This helper is useful when you want a button that performs a specific action (GET, POST, PUT, DELETE, PATCH) without manually creating a form.",
    "body": [
      "buttonTo()$0"
    ],
    "scope": "cfml"
  },
  "buttonTo(allParams)": {
    "prefix": "buttonTo",
    "description": "Creates a form containing a single button that submits to a URL. The URL is constructed the same way as linkTo(). This helper is useful when you want a button that performs a specific action (GET, POST, PUT, DELETE, PATCH) without manually creating a form.",
    "body": [
      "buttonTo(text = ${1:\"\"}, image = ${2:\"\"}, route = ${3:\"\"}, controller = ${4:\"\"}, action = ${5:\"\"}, key = ${6:\"\"}, params = ${7:\"\"}, anchor = ${8:\"\"}, method = ${9:\"\"}, onlyPath = ${10:\"True\"}, host = ${11:\"\"}, protocol = ${12:\"\"}, port = ${13:\"\"}, encode = ${14:\"True\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "caches": {
    "prefix": "caches",
    "description": "Tells Wheels to cache one or more controller actions. Caching improves performance by storing the output of actions so that repeated requests do not require re-running the action logic.",
    "body": [
      "caches()$0"
    ],
    "scope": "cfml"
  },
  "caches(allParams)": {
    "prefix": "caches",
    "description": "Tells Wheels to cache one or more controller actions. Caching improves performance by storing the output of actions so that repeated requests do not require re-running the action logic.",
    "body": [
      "caches(action = ${1:\"\"}, time = ${2:\"60\"}, static = ${3:\"\"}, appendToKey = ${4:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "clearCachableActions": {
    "prefix": "clearCachableActions",
    "description": "Removes one or more actions from the list of cacheable actions in a controller. Use this when you want to prevent previously cached actions from being cached or to reset caching for certain actions.",
    "body": [
      "clearCachableActions()$0"
    ],
    "scope": "cfml"
  },
  "clearCachableActions(allParams)": {
    "prefix": "clearCachableActions",
    "description": "Removes one or more actions from the list of cacheable actions in a controller. Use this when you want to prevent previously cached actions from being cached or to reset caching for certain actions.",
    "body": [
      "clearCachableActions(action = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "capitalize": {
    "prefix": "capitalize",
    "description": "Capitalizes the first letter of every word in the provided text, creating a nicely formatted title or sentence.",
    "body": [
      "capitalize(text = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "change": {
    "prefix": "change",
    "description": "Used in migrations to alter an existing table in the database. This function allows you to modify the structure of a table, such as adding, modifying, or removing columns.",
    "body": [
      "change()$0"
    ],
    "scope": "cfml"
  },
  "change(allParams)": {
    "prefix": "change",
    "description": "Used in migrations to alter an existing table in the database. This function allows you to modify the structure of a table, such as adding, modifying, or removing columns.",
    "body": [
      "change(addColumns = ${1:\"false\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "changeColumn": {
    "prefix": "changeColumn",
    "description": "Changes the definition of an existing column in a database table. This function is used in migration CFCs to update column properties such as type, size, default value, nullability, precision, and scale.",
    "body": [
      "changeColumn(table = ${1:\"\"}, columnName = ${2:\"\"}, columnType = ${3:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "changeColumn(allParams)": {
    "prefix": "changeColumn",
    "description": "Changes the definition of an existing column in a database table. This function is used in migration CFCs to update column properties such as type, size, default value, nullability, precision, and scale.",
    "body": [
      "changeColumn(table = ${1:\"\"}, columnName = ${2:\"\"}, columnType = ${3:\"\"}, afterColumn = ${4:\"\"}, referenceName = ${5:\"\"}, default = ${6:\"\"}, allowNull = ${7:\"\"}, limit = ${8:\"\"}, precision = ${9:\"\"}, scale = ${10:\"\"}, addColumns = ${11:\"false\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "changedFrom": {
    "prefix": "changedFrom",
    "description": "Returns the previous value of a property that has been modified on a model object. Wheels tracks changes to object properties until the object is saved to the database. If no previous value exists (the property was never modified), it returns an empty string. This is useful for auditing, logging, or conditional logic based on changes to object properties.",
    "body": [
      "changedFrom(property = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "changedProperties": {
    "prefix": "changedProperties",
    "description": "Returns a list of property names that have been modified on a model object but not yet saved to the database. This is useful for tracking which fields were updated, triggering specific actions based on changes, or performing conditional validation.",
    "body": [
      "changedProperties()$0"
    ],
    "scope": "cfml"
  },
  "changeTable": {
    "prefix": "changeTable",
    "description": "Creates a table definition object used to store and apply modifications to an existing table in the database. This function is only available inside a migration CFC and works in conjunction with table definition methods like string(), integer(), boolean(), etc., and the change() method to apply the changes.",
    "body": [
      "changeTable(name = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "char": {
    "prefix": "char",
    "description": "Adds one or more CHAR columns to a table definition in a migration. Use this function to define fixed-length string columns when creating or modifying a table.",
    "body": [
      "char()$0"
    ],
    "scope": "cfml"
  },
  "char(allParams)": {
    "prefix": "char",
    "description": "Adds one or more CHAR columns to a table definition in a migration. Use this function to define fixed-length string columns when creating or modifying a table.",
    "body": [
      "char(columnNames = ${1:\"\"}, limit = ${2:\"\"}, default = ${3:\"\"}, allowNull = ${4:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "checkBox": {
    "prefix": "checkBox",
    "description": "Builds and returns a string containing a check box form control based on the supplied name.\nNote: Pass any additional arguments like class, rel, and id, and the generated tag will also include those values as HTML attributes.",
    "body": [
      "checkBox(objectName = ${1:\"\"}, property = ${2:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "checkBox(allParams)": {
    "prefix": "checkBox",
    "description": "Builds and returns a string containing a check box form control based on the supplied name.\nNote: Pass any additional arguments like class, rel, and id, and the generated tag will also include those values as HTML attributes.",
    "body": [
      "checkBox(objectName = ${1:\"\"}, property = ${2:\"\"}, association = ${3:\"\"}, position = ${4:\"\"}, checkedValue = ${5:\"1\"}, uncheckedValue = ${6:\"\"}, label = ${7:\"useDefaultLabel\"}, labelPlacement = ${8:\"around\"}, prepend = ${9:\"\"}, append = ${10:\"\"}, prependToLabel = ${11:\"\"}, appendToLabel = ${12:\"\"}, errorElement = ${13:\"span\"}, errorClass = ${14:\"field-with-errors\"}, encode = ${15:\"True\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "checkBoxTag": {
    "prefix": "checkBoxTag",
    "description": "Builds and returns a string containing a check box form control based on the supplied name.\nNote: Pass any additional arguments like <code>class</code>, <code>rel</code>, and <code>id</code>, and the generated tag will also include those values as HTML attributes.",
    "body": [
      "checkBoxTag(name = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "checkBoxTag(allParams)": {
    "prefix": "checkBoxTag",
    "description": "Builds and returns a string containing a check box form control based on the supplied name.\nNote: Pass any additional arguments like <code>class</code>, <code>rel</code>, and <code>id</code>, and the generated tag will also include those values as HTML attributes.",
    "body": [
      "checkBoxTag(name = ${1:\"\"}, checked = ${2:\"\"}, value = ${3:\"1\"}, uncheckedValue = ${4:\"\"}, label = ${5:\"\"}, labelPlacement = ${6:\"around\"}, prepend = ${7:\"\"}, append = ${8:\"\"}, prependToLabel = ${9:\"\"}, appendToLabel = ${10:\"\"}, encode = ${11:\"True\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "clearChangeInformation": {
    "prefix": "clearChangeInformation",
    "description": "Clears all internal tracking information that Wheels maintains about an object’s properties. This does not undo changes made to the object—it simply resets the record of which properties are considered “changed,” so methods like hasChanged(), changedProperties(), or allChanges() will no longer report them. This is useful when you modify a property programmatically (for example, in a callback) and don’t want Wheels to attempt saving or reporting it as a change.",
    "body": [
      "clearChangeInformation()$0"
    ],
    "scope": "cfml"
  },
  "clearChangeInformation(allParams)": {
    "prefix": "clearChangeInformation",
    "description": "Clears all internal tracking information that Wheels maintains about an object’s properties. This does not undo changes made to the object—it simply resets the record of which properties are considered “changed,” so methods like hasChanged(), changedProperties(), or allChanges() will no longer report them. This is useful when you modify a property programmatically (for example, in a callback) and don’t want Wheels to attempt saving or reporting it as a change.",
    "body": [
      "clearChangeInformation(property = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "clearErrors": {
    "prefix": "clearErrors",
    "description": "Clears all validation or manual errors stored on a model object. You can clear all errors, or target specific errors either by property name or by a custom error name. This is useful when resetting an object’s state before re-validation, updating values programmatically, or handling conditional validation logic.",
    "body": [
      "clearErrors()$0"
    ],
    "scope": "cfml"
  },
  "clearErrors(allParams)": {
    "prefix": "clearErrors",
    "description": "Clears all validation or manual errors stored on a model object. You can clear all errors, or target specific errors either by property name or by a custom error name. This is useful when resetting an object’s state before re-validation, updating values programmatically, or handling conditional validation logic.",
    "body": [
      "clearErrors(property = ${1:\"\"}, name = ${2:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "collection": {
    "prefix": "collection",
    "description": "Defines a collection route in your Wheels application. Collection routes operate on a set of resources and do not require an id, unlike member routes which act on a single resource. This is useful when building actions that retrieve, filter, or display multiple objects, such as search pages, listings, or batch operations.",
    "body": [
      "collection()$0"
    ],
    "scope": "cfml"
  },
  "column": {
    "prefix": "column",
    "description": "Adds a column to a table definition in a migration. This function is used when defining or altering database tables. It supports multiple column types and allows you to specify constraints like default values, nullability, length, and precision. Use this inside a table definition object in a migration CFC when building or modifying tables.",
    "body": [
      "column(columnName = ${1:\"\"}, columnType = ${2:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "column(allParams)": {
    "prefix": "column",
    "description": "Adds a column to a table definition in a migration. This function is used when defining or altering database tables. It supports multiple column types and allows you to specify constraints like default values, nullability, length, and precision. Use this inside a table definition object in a migration CFC when building or modifying tables.",
    "body": [
      "column(columnName = ${1:\"\"}, columnType = ${2:\"\"}, default = ${3:\"\"}, allowNull = ${4:\"\"}, limit = ${5:\"\"}, precision = ${6:\"\"}, scale = ${7:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "columnDataForProperty": {
    "prefix": "columnDataForProperty",
    "description": "Returns a struct containing metadata about a specific property in a model. This includes information such as type, constraints, default values, and other column-specific details. It’s useful when you need to introspect the schema of your model dynamically.",
    "body": [
      "columnDataForProperty(property = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "columnForProperty": {
    "prefix": "columnForProperty",
    "description": "Returns the database column name that corresponds to a given model property. This is useful when your model property names differ from the actual database column names, or when you need to dynamically generate SQL queries or mappings.",
    "body": [
      "columnForProperty(property = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "columnNames": {
    "prefix": "columnNames",
    "description": "Returns a list of column names for the table mapped to this model. The list is ordered according to the columns’ ordinal positions in the database table. This is useful for dynamically generating queries, forms, or for inspecting the database structure associated with a model.",
    "body": [
      "columnNames()$0"
    ],
    "scope": "cfml"
  },
  "columns": {
    "prefix": "columns",
    "description": "Returns an array of database column names for the table associated with the model. This method excludes calculated or transient properties that are defined in the model but not stored in the database.",
    "body": [
      "columns()$0"
    ],
    "scope": "cfml"
  },
  "compareTo": {
    "prefix": "compareTo",
    "description": "Compares the current model object with another model object to determine if they are effectively the same. This is useful for checking equality between two instances of the same model before performing operations like updates or merges.",
    "body": [
      "compareTo(object = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "constraints": {
    "prefix": "constraints",
    "description": "Defines variable patterns for route parameters when setting up routes using the Wheels mapper(). This allows you to restrict the values that route parameters can take, such as limiting an id parameter to numbers only or enforcing a specific string format.",
    "body": [
      "constraints()$0"
    ],
    "scope": "cfml"
  },
  "contentFor": {
    "prefix": "contentFor",
    "description": "contentFor() is used to store a section's output in a layout. It allows you to define content in your view templates and then render it in a layout using #includeContent()#. The function maintains a stack for each section, so multiple pieces of content can be added in a controlled order.",
    "body": [
      "contentFor()$0"
    ],
    "scope": "cfml"
  },
  "contentFor(allParams)": {
    "prefix": "contentFor",
    "description": "contentFor() is used to store a section's output in a layout. It allows you to define content in your view templates and then render it in a layout using #includeContent()#. The function maintains a stack for each section, so multiple pieces of content can be added in a controlled order.",
    "body": [
      "contentFor(position = ${1:\"last\"}, overwrite = ${2:\"false\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "contentForLayout": {
    "prefix": "contentForLayout",
    "description": "contentForLayout() is used to render the main content of the current view inside a layout. In Wheels, when a controller action renders a view, that view generates content. This content can then be injected into the layout at the appropriate place using contentForLayout(). Essentially, it’s the placeholder for the view’s body content in your layout template.",
    "body": [
      "contentForLayout()$0"
    ],
    "scope": "cfml"
  },
  "controller": {
    "prefix": "controller",
    "description": "The controller() function creates and returns a controller object with a custom name and optional parameters. It is primarily used for testing, but can also be used in code to instantiate a controller programmatically. Unlike the deprecated routing controller() function, this helper does not define routes—it creates controller instances.",
    "body": [
      "controller(name = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "controller(allParams)": {
    "prefix": "controller",
    "description": "The controller() function creates and returns a controller object with a custom name and optional parameters. It is primarily used for testing, but can also be used in code to instantiate a controller programmatically. Unlike the deprecated routing controller() function, this helper does not define routes—it creates controller instances.",
    "body": [
      "controller(name = ${1:\"\"}, params = ${2:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "count": {
    "prefix": "count",
    "description": "The count() method calculates the number of records in a table that match a given set of conditions. It internally uses the SQL COUNT() function. If no arguments are provided, it returns the total number of rows in the table. It works on model classes.",
    "body": [
      "count()$0"
    ],
    "scope": "cfml"
  },
  "count(allParams)": {
    "prefix": "count",
    "description": "The count() method calculates the number of records in a table that match a given set of conditions. It internally uses the SQL COUNT() function. If no arguments are provided, it returns the total number of rows in the table. It works on model classes.",
    "body": [
      "count(where = ${1:\"\"}, include = ${2:\"\"}, parameterize = ${3:\"True\"}, includeSoftDeletes = ${4:\"false\"}, group = ${5:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "create": {
    "prefix": "create",
    "description": "The create() method is used to instantiate a new model object, set its properties, and save it to the database (if validations pass). Even if validation fails, the method still returns the unsaved object, including any validation errors. It’s a higher-level convenience function that combines object creation, property assignment, validation, and saving into a single call. Property names and values can be passed in either using named arguments or as a struct to the properties argument.",
    "body": [
      "create()$0"
    ],
    "scope": "cfml"
  },
  "create(allParams)": {
    "prefix": "create",
    "description": "The create() method is used to instantiate a new model object, set its properties, and save it to the database (if validations pass). Even if validation fails, the method still returns the unsaved object, including any validation errors. It’s a higher-level convenience function that combines object creation, property assignment, validation, and saving into a single call. Property names and values can be passed in either using named arguments or as a struct to the properties argument.",
    "body": [
      "create(properties = ${1:\"\"}, parameterize = ${2:\"True\"}, reload = ${3:\"\"}, validate = ${4:\"True\"}, transaction = ${5:\"\"}, callbacks = ${6:\"True\"}, allowExplicitTimestamps = ${7:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "createMigration": {
    "prefix": "createMigration",
    "description": "The createMigration() method is used to generate a new migration file for managing database schema changes. While you can call it from your application code, it is primarily intended for use via the CLI or Wheels GUI. A migration file allows you to define table creations, modifications, or deletions in a structured way that can be applied or rolled back consistently.",
    "body": [
      "createMigration(migrationName = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "createMigration(allParams)": {
    "prefix": "createMigration",
    "description": "The createMigration() method is used to generate a new migration file for managing database schema changes. While you can call it from your application code, it is primarily intended for use via the CLI or Wheels GUI. A migration file allows you to define table creations, modifications, or deletions in a structured way that can be applied or rolled back consistently.",
    "body": [
      "createMigration(migrationName = ${1:\"\"}, templateName = ${2:\"\"}, migrationPrefix = ${3:\"timestamp\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "createTable": {
    "prefix": "createTable",
    "description": "The createTable() function is used in migration CFCs to define a new database table. It returns a TableDefinition object, on which you can specify columns, primary keys, timestamps, and other table properties. Once the table is defined, you call create() to actually create it in the database.",
    "body": [
      "createTable(name = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "createTable(allParams)": {
    "prefix": "createTable",
    "description": "The createTable() function is used in migration CFCs to define a new database table. It returns a TableDefinition object, on which you can specify columns, primary keys, timestamps, and other table properties. Once the table is defined, you call create() to actually create it in the database.",
    "body": [
      "createTable(name = ${1:\"\"}, force = ${2:\"false\"}, id = ${3:\"true\"}, primaryKey = ${4:\"id\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "createView": {
    "prefix": "createView",
    "description": "The createView() function is used in migration CFCs to define a new database view. It returns a ViewDefinition object, on which you can specify the view’s SQL query and properties. Once the view is fully defined, you call create() to actually create it in the database.",
    "body": [
      "createView(name = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "csrfMetaTags": {
    "prefix": "csrfMetaTags",
    "description": "The csrfMetaTags() helper generates meta tags containing your application's CSRF authenticity token. This is useful for JavaScript/AJAX requests that need to POST data securely, ensuring that the request comes from a trusted source.",
    "body": [
      "csrfMetaTags()$0"
    ],
    "scope": "cfml"
  },
  "cycle": {
    "prefix": "cycle",
    "description": "cycle() is a view helper used to loop through a list of values sequentially, returning the next value each time it’s called. This is especially useful for things like alternating row colors in tables or assigning sequential classes in repeated HTML elements.",
    "body": [
      "cycle(values = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "cycle(allParams)": {
    "prefix": "cycle",
    "description": "cycle() is a view helper used to loop through a list of values sequentially, returning the next value each time it’s called. This is especially useful for things like alternating row colors in tables or assigning sequential classes in repeated HTML elements.",
    "body": [
      "cycle(values = ${1:\"\"}, name = ${2:\"default\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "dataSource": {
    "prefix": "dataSource",
    "description": "dataSource() is a model configuration method used to override the default database connection for a specific model. This is useful when you want a model to query a different database or use specific credentials than the application default.",
    "body": [
      "dataSource(datasource = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "dataSource(allParams)": {
    "prefix": "dataSource",
    "description": "dataSource() is a model configuration method used to override the default database connection for a specific model. This is useful when you want a model to query a different database or use specific credentials than the application default.",
    "body": [
      "dataSource(datasource = ${1:\"\"}, username = ${2:\"\"}, password = ${3:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "date": {
    "prefix": "date",
    "description": "date() is a table definition function used in a migration CFC to add one or more DATE columns to a table.",
    "body": [
      "date()$0"
    ],
    "scope": "cfml"
  },
  "date(allParams)": {
    "prefix": "date",
    "description": "date() is a table definition function used in a migration CFC to add one or more DATE columns to a table.",
    "body": [
      "date(columnNames = ${1:\"\"}, default = ${2:\"\"}, allowNull = ${3:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "dateSelect": {
    "prefix": "dateSelect",
    "description": "Builds and returns a string containing three <code>select</code> form controls for month, day, and year based on the supplied <code>objectName</code> and <code>property</code>.",
    "body": [
      "dateSelect()$0"
    ],
    "scope": "cfml"
  },
  "dateSelect(allParams)": {
    "prefix": "dateSelect",
    "description": "Builds and returns a string containing three <code>select</code> form controls for month, day, and year based on the supplied <code>objectName</code> and <code>property</code>.",
    "body": [
      "dateSelect(objectName = ${1:\"\"}, property = ${2:\"\"}, association = ${3:\"\"}, position = ${4:\"\"}, order = ${5:\"month,day,year\"}, separator = ${6:\" \"}, startYear = ${7:\"2018\"}, endYear = ${8:\"2028\"}, monthDisplay = ${9:\"names\"}, monthNames = ${10:\"January,February,March,April,May,June,July,August,September,October,November,December\"}, monthAbbreviations = ${11:\"Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec\"}, includeBlank = ${12:\"\"}, label = ${13:\"\"}, labelPlacement = ${14:\"around\"}, prepend = ${15:\"\"}, append = ${16:\"\"}, prependToLabel = ${17:\"\"}, appendToLabel = ${18:\"\"}, errorElement = ${19:\"span\"}, errorClass = ${20:\"field-with-errors\"}, combine = ${21:\"\"}, encode = ${22:\"True\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "dateSelectTags": {
    "prefix": "dateSelectTags",
    "description": "dateSelectTags() is similar to dateSelect(), but instead of binding to a model object, it works directly with a name and selected value. It generates three select dropdowns (month, day, year) for form tags.",
    "body": [
      "dateSelectTags(name = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "dateSelectTags(allParams)": {
    "prefix": "dateSelectTags",
    "description": "dateSelectTags() is similar to dateSelect(), but instead of binding to a model object, it works directly with a name and selected value. It generates three select dropdowns (month, day, year) for form tags.",
    "body": [
      "dateSelectTags(name = ${1:\"\"}, selected = ${2:\"\"}, order = ${3:\"month,day,year\"}, separator = ${4:\" \"}, startYear = ${5:\"2018\"}, endYear = ${6:\"2028\"}, monthDisplay = ${7:\"names\"}, monthNames = ${8:\"January,February,March,April,May,June,July,August,September,October,November,December\"}, monthAbbreviations = ${9:\"Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec\"}, includeBlank = ${10:\"\"}, label = ${11:\"\"}, labelPlacement = ${12:\"around\"}, prepend = ${13:\"\"}, append = ${14:\"\"}, prependToLabel = ${15:\"\"}, appendToLabel = ${16:\"\"}, combine = ${17:\"\"}, encode = ${18:\"True\"}, $now = ${19:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "datetime": {
    "prefix": "datetime",
    "description": "Adds datetime columns to a table definition when creating or altering a table in a migration. These columns store both date and time values.",
    "body": [
      "datetime()$0"
    ],
    "scope": "cfml"
  },
  "datetime(allParams)": {
    "prefix": "datetime",
    "description": "Adds datetime columns to a table definition when creating or altering a table in a migration. These columns store both date and time values.",
    "body": [
      "datetime(columnNames = ${1:\"\"}, default = ${2:\"\"}, allowNull = ${3:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "dateTimeSelect": {
    "prefix": "dateTimeSelect",
    "description": "Builds and returns a string containing six <code>select</code> form controls (three for date selection and the remaining three for time selection) based on the supplied objectName and property.",
    "body": [
      "dateTimeSelect(objectName = ${1:\"\"}, property = ${2:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "dateTimeSelect(allParams)": {
    "prefix": "dateTimeSelect",
    "description": "Builds and returns a string containing six <code>select</code> form controls (three for date selection and the remaining three for time selection) based on the supplied objectName and property.",
    "body": [
      "dateTimeSelect(objectName = ${1:\"\"}, property = ${2:\"\"}, association = ${3:\"\"}, position = ${4:\"\"}, dateOrder = ${5:\"month,day,year\"}, dateSeparator = ${6:\" \"}, startYear = ${7:\"2018\"}, endYear = ${8:\"2028\"}, monthDisplay = ${9:\"names\"}, monthNames = ${10:\"January,February,March,April,May,June,July,August,September,October,November,December\"}, monthAbbreviations = ${11:\"Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec\"}, timeOrder = ${12:\"hour,minute,second\"}, timeSeparator = ${13:\":\"}, minuteStep = ${14:\"1\"}, secondStep = ${15:\"1\"}, separator = ${16:\" - \"}, includeBlank = ${17:\"\"}, label = ${18:\"\"}, labelPlacement = ${19:\"around\"}, prepend = ${20:\"\"}, append = ${21:\"\"}, prependToLabel = ${22:\"\"}, appendToLabel = ${23:\"\"}, errorElement = ${24:\"span\"}, errorClass = ${25:\"field-with-errors\"}, combine = ${26:\"\"}, twelveHour = ${27:\"\"}, encode = ${28:\"True\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "dateTimeSelectTags": {
    "prefix": "dateTimeSelectTags",
    "description": "Builds and returns a string containing six <code>select</code> form controls (three for date selection and the remaining three for time selection) based on a name.",
    "body": [
      "dateTimeSelectTags(name = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "dateTimeSelectTags(allParams)": {
    "prefix": "dateTimeSelectTags",
    "description": "Builds and returns a string containing six <code>select</code> form controls (three for date selection and the remaining three for time selection) based on a name.",
    "body": [
      "dateTimeSelectTags(name = ${1:\"\"}, selected = ${2:\"\"}, dateOrder = ${3:\"month,day,year\"}, dateSeparator = ${4:\" \"}, startYear = ${5:\"2018\"}, endYear = ${6:\"2028\"}, monthDisplay = ${7:\"names\"}, monthNames = ${8:\"January,February,March,April,May,June,July,August,September,October,November,December\"}, monthAbbreviations = ${9:\"Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec\"}, timeOrder = ${10:\"hour,minute,second\"}, timeSeparator = ${11:\":\"}, minuteStep = ${12:\"1\"}, secondStep = ${13:\"1\"}, separator = ${14:\" - \"}, includeBlank = ${15:\"\"}, label = ${16:\"\"}, labelPlacement = ${17:\"around\"}, prepend = ${18:\"\"}, append = ${19:\"\"}, prependToLabel = ${20:\"\"}, appendToLabel = ${21:\"\"}, combine = ${22:\"\"}, twelveHour = ${23:\"\"}, encode = ${24:\"True\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "daySelectTag": {
    "prefix": "daySelectTag",
    "description": "Builds and returns a string containing a <code>select</code> form control for the days of the week based on the supplied name. This version works without binding to a model object.",
    "body": [
      "daySelectTag(name = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "daySelectTag(allParams)": {
    "prefix": "daySelectTag",
    "description": "Builds and returns a string containing a <code>select</code> form control for the days of the week based on the supplied name. This version works without binding to a model object.",
    "body": [
      "daySelectTag(name = ${1:\"\"}, selected = ${2:\"\"}, includeBlank = ${3:\"\"}, label = ${4:\"\"}, labelPlacement = ${5:\"around\"}, prepend = ${6:\"\"}, append = ${7:\"\"}, prependToLabel = ${8:\"\"}, appendToLabel = ${9:\"\"}, encode = ${10:\"True\"}, $now = ${11:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "debug": {
    "prefix": "debug",
    "description": "Used in tests to inspect any expression. It behaves like a cfdump but is tailored for the testing environment. This helps you examine values while writing or running legacy tests.",
    "body": [
      "debug(expression = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "debug(allParams)": {
    "prefix": "debug",
    "description": "Used in tests to inspect any expression. It behaves like a cfdump but is tailored for the testing environment. This helps you examine values while writing or running legacy tests.",
    "body": [
      "debug(expression = ${1:\"\"}, display = ${2:\"True\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "decimal": {
    "prefix": "decimal",
    "description": "Adds decimal (numeric) columns to a table definition when creating or altering tables via a migration CFC.",
    "body": [
      "decimal()$0"
    ],
    "scope": "cfml"
  },
  "decimal(allParams)": {
    "prefix": "decimal",
    "description": "Adds decimal (numeric) columns to a table definition when creating or altering tables via a migration CFC.",
    "body": [
      "decimal(columnNames = ${1:\"\"}, default = ${2:\"\"}, allowNull = ${3:\"\"}, precision = ${4:\"\"}, scale = ${5:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "delete": {
    "prefix": "delete",
    "description": "Deletes the object, which means the row is deleted from the database (unless prevented by a <code>beforeDelete</code> callback).\nReturns <code>true</code> on successful deletion of the row, <code>false</code> otherwise.",
    "body": [
      "delete()$0"
    ],
    "scope": "cfml"
  },
  "delete(allParams)": {
    "prefix": "delete",
    "description": "Deletes the object, which means the row is deleted from the database (unless prevented by a <code>beforeDelete</code> callback).\nReturns <code>true</code> on successful deletion of the row, <code>false</code> otherwise.",
    "body": [
      "delete(parameterize = ${1:\"True\"}, transaction = ${2:\"\"}, callbacks = ${3:\"True\"}, includeSoftDeletes = ${4:\"\"}, softDelete = ${5:\"True\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "deleteAll": {
    "prefix": "deleteAll",
    "description": "Deletes all records that match the <code>where</code> argument.\nBy default, objects will not be instantiated and therefore callbacks and validations are not invoked.\nYou can change this behavior by passing in <code>instantiate=true</code>.\nReturns the number of records that were deleted.",
    "body": [
      "deleteAll()$0"
    ],
    "scope": "cfml"
  },
  "deleteAll(allParams)": {
    "prefix": "deleteAll",
    "description": "Deletes all records that match the <code>where</code> argument.\nBy default, objects will not be instantiated and therefore callbacks and validations are not invoked.\nYou can change this behavior by passing in <code>instantiate=true</code>.\nReturns the number of records that were deleted.",
    "body": [
      "deleteAll(where = ${1:\"\"}, include = ${2:\"\"}, reload = ${3:\"\"}, parameterize = ${4:\"True\"}, instantiate = ${5:\"\"}, transaction = ${6:\"\"}, callbacks = ${7:\"True\"}, useIndex = ${8:\"\"}, includeSoftDeletes = ${9:\"\"}, softDelete = ${10:\"True\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "deleteByKey": {
    "prefix": "deleteByKey",
    "description": "Finds the record with the supplied key and deletes it.\nReturns <code>true</code> on successful deletion of the row, <code>false</code> otherwise.",
    "body": [
      "deleteByKey(key = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "deleteByKey(allParams)": {
    "prefix": "deleteByKey",
    "description": "Finds the record with the supplied key and deletes it.\nReturns <code>true</code> on successful deletion of the row, <code>false</code> otherwise.",
    "body": [
      "deleteByKey(key = ${1:\"\"}, reload = ${2:\"\"}, transaction = ${3:\"\"}, callbacks = ${4:\"True\"}, includeSoftDeletes = ${5:\"\"}, softDelete = ${6:\"True\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "deleteOne": {
    "prefix": "deleteOne",
    "description": "Finds a single record based on conditions and deletes it. Returns true if deletion succeeds, false otherwise. It is useful when you want to remove one specific record without fetching it manually first.",
    "body": [
      "deleteOne()$0"
    ],
    "scope": "cfml"
  },
  "deleteOne(allParams)": {
    "prefix": "deleteOne",
    "description": "Finds a single record based on conditions and deletes it. Returns true if deletion succeeds, false otherwise. It is useful when you want to remove one specific record without fetching it manually first.",
    "body": [
      "deleteOne(where = ${1:\"\"}, order = ${2:\"\"}, reload = ${3:\"\"}, transaction = ${4:\"\"}, callbacks = ${5:\"True\"}, useIndex = ${6:\"\"}, includeSoftDeletes = ${7:\"\"}, softDelete = ${8:\"True\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "deobfuscateParam": {
    "prefix": "deobfuscateParam",
    "description": "Converts an obfuscated string back into its original value. This is typically used when IDs or other sensitive data are encoded for security purposes and need to be restored to their original form.",
    "body": [
      "deobfuscateParam(param = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "distanceOfTimeInWords": {
    "prefix": "distanceOfTimeInWords",
    "description": "Pass in two dates to this method, and it will return a string describing the difference between them.",
    "body": [
      "distanceOfTimeInWords(fromTime = ${1:\"\"}, toTime = ${2:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "distanceOfTimeInWords(allParams)": {
    "prefix": "distanceOfTimeInWords",
    "description": "Pass in two dates to this method, and it will return a string describing the difference between them.",
    "body": [
      "distanceOfTimeInWords(fromTime = ${1:\"\"}, toTime = ${2:\"\"}, includeSeconds = ${3:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "down": {
    "prefix": "down",
    "description": "down() defines the steps to revert a database migration. It’s executed when rolling back a migration, typically to undo the changes applied by the corresponding up() function. Only available in a migration CFC",
    "body": [
      "down()$0"
    ],
    "scope": "cfml"
  },
  "dropForeignKey": {
    "prefix": "dropForeignKey",
    "description": "dropForeignKey() is used to remove a foreign key constraint from a table in the database. This is typically done during schema changes in migrations. Only available in a migration CFC.",
    "body": [
      "dropForeignKey(table = ${1:\"\"}, keyName = ${2:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "dropReference": {
    "prefix": "dropReference",
    "description": "dropReference() is used to remove a foreign key constraint from a table in the database using the reference name that was originally used to create it. This is slightly different from dropForeignKey(), which requires the actual key name. Only available in a migration CFC",
    "body": [
      "dropReference(table = ${1:\"\"}, referenceName = ${2:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "dropTable": {
    "prefix": "dropTable",
    "description": "dropTable() is used to remove a table from the database entirely. This is a destructive operation, so all data in the table will be lost. Only available in a migration CFC",
    "body": [
      "dropTable(name = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "dropView": {
    "prefix": "dropView",
    "description": "dropView() is used to remove a database view entirely. A view is a saved query that acts like a virtual table, so this operation deletes that virtual table definition. Only available in a migration CFC",
    "body": [
      "dropView(name = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "end": {
    "prefix": "end",
    "description": "Call this to end a nested routing block or the entire route configuration. This method is chained on a sequence of routing mapper method calls started by <code>mapper()</code>.",
    "body": [
      "end()$0"
    ],
    "scope": "cfml"
  },
  "endFormTag": {
    "prefix": "endFormTag",
    "description": "Builds and returns a string containing the closing <code>form</code> tag. It’s typically used in conjunction with startFormTag().",
    "body": [
      "endFormTag()$0"
    ],
    "scope": "cfml"
  },
  "endFormTag(allParams)": {
    "prefix": "endFormTag",
    "description": "Builds and returns a string containing the closing <code>form</code> tag. It’s typically used in conjunction with startFormTag().",
    "body": [
      "endFormTag(prepend = ${1:\"\"}, append = ${2:\"\"}, encode = ${3:\"True\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "errorCount": {
    "prefix": "errorCount",
    "description": "Returns the number of errors this object has associated with it.\nSpecify property or name if you wish to count only specific errors.",
    "body": [
      "errorCount()$0"
    ],
    "scope": "cfml"
  },
  "errorCount(allParams)": {
    "prefix": "errorCount",
    "description": "Returns the number of errors this object has associated with it.\nSpecify property or name if you wish to count only specific errors.",
    "body": [
      "errorCount(property = ${1:\"\"}, name = ${2:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "errorMessageOn": {
    "prefix": "errorMessageOn",
    "description": "Returns the error message, if one exists, on the object's property.\nIf multiple error messages exist, the first one is returned. If no error exists, it returns an empty string.",
    "body": [
      "errorMessageOn(objectName = ${1:\"\"}, property = ${2:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "errorMessageOn(allParams)": {
    "prefix": "errorMessageOn",
    "description": "Returns the error message, if one exists, on the object's property.\nIf multiple error messages exist, the first one is returned. If no error exists, it returns an empty string.",
    "body": [
      "errorMessageOn(objectName = ${1:\"\"}, property = ${2:\"\"}, prependText = ${3:\"\"}, appendText = ${4:\"\"}, wrapperElement = ${5:\"span\"}, class = ${6:\"error-message\"}, encode = ${7:\"True\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "errorMessagesFor": {
    "prefix": "errorMessagesFor",
    "description": "Builds and returns a list (<code>ul</code> tag with a default <code>class</code> of <code>error-messages</code>) containing all the error messages for all the properties of the object.\nReturns an empty string if no errors exist.",
    "body": [
      "errorMessagesFor(objectName = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "errorMessagesFor(allParams)": {
    "prefix": "errorMessagesFor",
    "description": "Builds and returns a list (<code>ul</code> tag with a default <code>class</code> of <code>error-messages</code>) containing all the error messages for all the properties of the object.\nReturns an empty string if no errors exist.",
    "body": [
      "errorMessagesFor(objectName = ${1:\"\"}, class = ${2:\"error-messages\"}, showDuplicates = ${3:\"True\"}, encode = ${4:\"True\"}, includeAssociations = ${5:\"True\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "errorsOn": {
    "prefix": "errorsOn",
    "description": "errorsOn() returns an array of all errors associated with a specific property of a model object. You can also filter by a specific error name if needed. This is useful when you need programmatic access to errors rather than just displaying them in the view.",
    "body": [
      "errorsOn(property = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "errorsOn(allParams)": {
    "prefix": "errorsOn",
    "description": "errorsOn() returns an array of all errors associated with a specific property of a model object. You can also filter by a specific error name if needed. This is useful when you need programmatic access to errors rather than just displaying them in the view.",
    "body": [
      "errorsOn(property = ${1:\"\"}, name = ${2:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "errorsOnBase": {
    "prefix": "errorsOnBase",
    "description": "errorsOnBase() returns an array of all errors associated with the object as a whole, not tied to any specific property. This is useful for general errors such as system-level validations, cross-field validations, or custom errors added at the object level.",
    "body": [
      "errorsOnBase()$0"
    ],
    "scope": "cfml"
  },
  "errorsOnBase(allParams)": {
    "prefix": "errorsOnBase",
    "description": "errorsOnBase() returns an array of all errors associated with the object as a whole, not tied to any specific property. This is useful for general errors such as system-level validations, cross-field validations, or custom errors added at the object level.",
    "body": [
      "errorsOnBase(name = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "excerpt": {
    "prefix": "excerpt",
    "description": "excerpt() extracts a portion of text surrounding the first instance of a given phrase. This is useful for previews, search result snippets, or highlighting context around a keyword.",
    "body": [
      "excerpt(text = ${1:\"\"}, phrase = ${2:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "excerpt(allParams)": {
    "prefix": "excerpt",
    "description": "excerpt() extracts a portion of text surrounding the first instance of a given phrase. This is useful for previews, search result snippets, or highlighting context around a keyword.",
    "body": [
      "excerpt(text = ${1:\"\"}, phrase = ${2:\"\"}, radius = ${3:\"100\"}, excerptString = ${4:\"...\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "execute": {
    "prefix": "execute",
    "description": "execute() allows you to run a raw SQL query directly from a migration file. This is useful when you need to perform operations that aren’t easily handled by the built-in migration methods like createTable() or addColumn(). Only available in a migration CFC",
    "body": [
      "execute(sql = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "exists": {
    "prefix": "exists",
    "description": "Checks if a record exists in the table.\nYou can pass in either a primary key value to the <code>key</code> argument or a string to the <code>where</code> argument.\nIf you don't pass in either of those, it will simply check if any record exists in the table.",
    "body": [
      "exists()$0"
    ],
    "scope": "cfml"
  },
  "exists(allParams)": {
    "prefix": "exists",
    "description": "Checks if a record exists in the table.\nYou can pass in either a primary key value to the <code>key</code> argument or a string to the <code>where</code> argument.\nIf you don't pass in either of those, it will simply check if any record exists in the table.",
    "body": [
      "exists(key = ${1:\"\"}, where = ${2:\"\"}, reload = ${3:\"\"}, parameterize = ${4:\"True\"}, includeSoftDeletes = ${5:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "fail": {
    "prefix": "fail",
    "description": "Forces a test to fail intentionally. You can call fail() inside a test when you want to stop execution and explicitly mark the test as failed or highlight cases that should never happen. When called, it throws an exception that results in a test failure. You can optionally pass a custom message to clarify why the failure occurred. Used in wheels legacy testing.",
    "body": [
      "fail()$0"
    ],
    "scope": "cfml"
  },
  "fail(allParams)": {
    "prefix": "fail",
    "description": "Forces a test to fail intentionally. You can call fail() inside a test when you want to stop execution and explicitly mark the test as failed or highlight cases that should never happen. When called, it throws an exception that results in a test failure. You can optionally pass a custom message to clarify why the failure occurred. Used in wheels legacy testing.",
    "body": [
      "fail(message = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "fileField": {
    "prefix": "fileField",
    "description": "Builds and returns a string containing a file field form control based on the supplied objectName and property.\nNote: Pass any additional arguments like class, rel, and id, and the generated tag will also include those values as HTML attributes.",
    "body": [
      "fileField(objectName = ${1:\"\"}, property = ${2:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "fileField(allParams)": {
    "prefix": "fileField",
    "description": "Builds and returns a string containing a file field form control based on the supplied objectName and property.\nNote: Pass any additional arguments like class, rel, and id, and the generated tag will also include those values as HTML attributes.",
    "body": [
      "fileField(objectName = ${1:\"\"}, property = ${2:\"\"}, association = ${3:\"\"}, position = ${4:\"\"}, label = ${5:\"useDefaultLabel\"}, labelPlacement = ${6:\"around\"}, prepend = ${7:\"\"}, append = ${8:\"\"}, prependToLabel = ${9:\"\"}, appendToLabel = ${10:\"\"}, errorElement = ${11:\"span\"}, errorClass = ${12:\"field-with-errors\"}, encode = ${13:\"True\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "fileFieldTag": {
    "prefix": "fileFieldTag",
    "description": "Builds and returns a string containing a file form control based on the supplied name.\nNote: Pass any additional arguments like <code>class</code>, <code>rel</code>, and <code>id</code>, and the generated tag will also include those values as HTML attributes.",
    "body": [
      "fileFieldTag(name = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "fileFieldTag(allParams)": {
    "prefix": "fileFieldTag",
    "description": "Builds and returns a string containing a file form control based on the supplied name.\nNote: Pass any additional arguments like <code>class</code>, <code>rel</code>, and <code>id</code>, and the generated tag will also include those values as HTML attributes.",
    "body": [
      "fileFieldTag(name = ${1:\"\"}, label = ${2:\"\"}, labelPlacement = ${3:\"around\"}, prepend = ${4:\"\"}, append = ${5:\"\"}, prependToLabel = ${6:\"\"}, appendToLabel = ${7:\"\"}, encode = ${8:\"True\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "filterChain": {
    "prefix": "filterChain",
    "description": "The filterChain() function returns an array of all filters that are set on the current controller in the order they will be executed. By default, it includes both before and after filters, but you can specify the type argument if you want to return only one type. For example, setting type=\"after\" will return only the filters that run after the controller action.",
    "body": [
      "filterChain()$0"
    ],
    "scope": "cfml"
  },
  "filterChain(allParams)": {
    "prefix": "filterChain",
    "description": "The filterChain() function returns an array of all filters that are set on the current controller in the order they will be executed. By default, it includes both before and after filters, but you can specify the type argument if you want to return only one type. For example, setting type=\"after\" will return only the filters that run after the controller action.",
    "body": [
      "filterChain(type = ${1:\"all\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "filters": {
    "prefix": "filters",
    "description": "The filters() function lets you specify methods in your controller that should run automatically either before or after certain actions. Filters are useful for handling cross-cutting concerns such as authentication, authorization, logging, or cleanup, without having to repeat the same code inside each action. By default, filters run before the action, but you can configure them to run after, limit them to specific actions, exclude them from others, or control their placement in the filter chain.",
    "body": [
      "filters(through = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "filters(allParams)": {
    "prefix": "filters",
    "description": "The filters() function lets you specify methods in your controller that should run automatically either before or after certain actions. Filters are useful for handling cross-cutting concerns such as authentication, authorization, logging, or cleanup, without having to repeat the same code inside each action. By default, filters run before the action, but you can configure them to run after, limit them to specific actions, exclude them from others, or control their placement in the filter chain.",
    "body": [
      "filters(through = ${1:\"\"}, type = ${2:\"before\"}, only = ${3:\"\"}, except = ${4:\"\"}, placement = ${5:\"append\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "findAll": {
    "prefix": "findAll",
    "description": "Returns records from the database table mapped to this model according to the arguments passed in (use the <code>where</code> argument to decide which records to get, use the <code>order</code> argument to set the order in which those records should be returned, and so on).\nThe records will be returned as either a <code>cfquery</code> result set, an array of objects, or an array of structs (depending on what the <code>returnAs</code> argument is set to).",
    "body": [
      "findAll()$0"
    ],
    "scope": "cfml"
  },
  "findAll(allParams)": {
    "prefix": "findAll",
    "description": "Returns records from the database table mapped to this model according to the arguments passed in (use the <code>where</code> argument to decide which records to get, use the <code>order</code> argument to set the order in which those records should be returned, and so on).\nThe records will be returned as either a <code>cfquery</code> result set, an array of objects, or an array of structs (depending on what the <code>returnAs</code> argument is set to).",
    "body": [
      "findAll(where = ${1:\"\"}, order = ${2:\"\"}, group = ${3:\"\"}, select = ${4:\"\"}, distinct = ${5:\"false\"}, include = ${6:\"\"}, maxRows = ${7:\"-1\"}, page = ${8:\"0\"}, perPage = ${9:\"10\"}, count = ${10:\"0\"}, handle = ${11:\"query\"}, cache = ${12:\"\"}, reload = ${13:\"\"}, parameterize = ${14:\"True\"}, returnAs = ${15:\"query\"}, returnIncluded = ${16:\"True\"}, callbacks = ${17:\"true\"}, includeSoftDeletes = ${18:\"false\"}, useIndex = ${19:\"\"}, dataSource = ${20:\"\"}, $limit = ${21:\"0\"}, $offset = ${22:\"0\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "findAllKeys": {
    "prefix": "findAllKeys",
    "description": "The findAllKeys() function retrieves all primary key values for a model’s records and returns them as a list. By default, the values are separated with commas, but you can change the delimiter with the delimiter argument or add single quotes around each value with the quoted argument. Since findAllKeys() accepts all arguments that findAll() does, you can also filter results with where, control ordering with order, or even include associations when filtering. This makes it useful when you need just the IDs of records without fetching full objects or rows.",
    "body": [
      "findAllKeys()$0"
    ],
    "scope": "cfml"
  },
  "findAllKeys(allParams)": {
    "prefix": "findAllKeys",
    "description": "The findAllKeys() function retrieves all primary key values for a model’s records and returns them as a list. By default, the values are separated with commas, but you can change the delimiter with the delimiter argument or add single quotes around each value with the quoted argument. Since findAllKeys() accepts all arguments that findAll() does, you can also filter results with where, control ordering with order, or even include associations when filtering. This makes it useful when you need just the IDs of records without fetching full objects or rows.",
    "body": [
      "findAllKeys(quoted = ${1:\"false\"}, delimiter = ${2:\",\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "findByKey": {
    "prefix": "findByKey",
    "description": "The findByKey() function retrieves a single record from the database using its primary key value and returns it as an object by default. If the record is not found, it returns false, making it easy to handle missing data gracefully. You can also control what columns are returned using the select argument, include related associations, or override the return format to a query, struct, or even raw SQL. Since it accepts the same options as other read functions like findOne(), you can apply caching, indexing, and even include soft-deleted records when needed.",
    "body": [
      "findByKey(key = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "findByKey(allParams)": {
    "prefix": "findByKey",
    "description": "The findByKey() function retrieves a single record from the database using its primary key value and returns it as an object by default. If the record is not found, it returns false, making it easy to handle missing data gracefully. You can also control what columns are returned using the select argument, include related associations, or override the return format to a query, struct, or even raw SQL. Since it accepts the same options as other read functions like findOne(), you can apply caching, indexing, and even include soft-deleted records when needed.",
    "body": [
      "findByKey(key = ${1:\"\"}, select = ${2:\"\"}, include = ${3:\"\"}, handle = ${4:\"query\"}, cache = ${5:\"\"}, reload = ${6:\"\"}, parameterize = ${7:\"True\"}, returnAs = ${8:\"object\"}, callbacks = ${9:\"true\"}, includeSoftDeletes = ${10:\"false\"}, dataSource = ${11:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "findFirst": {
    "prefix": "findFirst",
    "description": "The findFirst() function fetches the first record from the database table mapped to the model, ordered by the primary key value by default. You can customize the ordering by passing a property name through the property argument, which is also aliased as properties. This makes it useful when you want the \"first\" record based on a specific field (e.g., earliest created date, alphabetically first name, lowest price, etc.). The result is returned as a model object.",
    "body": [
      "findFirst()$0"
    ],
    "scope": "cfml"
  },
  "findFirst(allParams)": {
    "prefix": "findFirst",
    "description": "The findFirst() function fetches the first record from the database table mapped to the model, ordered by the primary key value by default. You can customize the ordering by passing a property name through the property argument, which is also aliased as properties. This makes it useful when you want the \"first\" record based on a specific field (e.g., earliest created date, alphabetically first name, lowest price, etc.). The result is returned as a model object.",
    "body": [
      "findFirst(property = ${1:\"\"}, $sort = ${2:\"ASC\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "findLastOne": {
    "prefix": "findLastOne",
    "description": "The findLastOne() function fetches the last record from the database table mapped to the model, ordered by the primary key value by default. You can override this ordering by passing a property name through the property argument (also aliased as properties). This is useful when you want to retrieve the \"last\" record based on something other than the primary key, such as the most recently created entry, the highest price, or the latest updated timestamp. The result is returned as a model object. This function was formerly known as findLast.",
    "body": [
      "findLastOne()$0"
    ],
    "scope": "cfml"
  },
  "findLastOne(allParams)": {
    "prefix": "findLastOne",
    "description": "The findLastOne() function fetches the last record from the database table mapped to the model, ordered by the primary key value by default. You can override this ordering by passing a property name through the property argument (also aliased as properties). This is useful when you want to retrieve the \"last\" record based on something other than the primary key, such as the most recently created entry, the highest price, or the latest updated timestamp. The result is returned as a model object. This function was formerly known as findLast.",
    "body": [
      "findLastOne(property = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "findOne": {
    "prefix": "findOne",
    "description": "Fetches the first record found based on the <code>WHERE</code> and <code>ORDER BY</code> clauses.\nWith the default settings (i.e. the <code>returnAs</code> argument set to <code>object</code>), a model object will be returned if the record is found and the boolean value <code>false</code> if not.\nInstead of using the <code>where</code> argument, you can create cleaner code by making use of a concept called Dynamic Finders.",
    "body": [
      "findOne()$0"
    ],
    "scope": "cfml"
  },
  "findOne(allParams)": {
    "prefix": "findOne",
    "description": "Fetches the first record found based on the <code>WHERE</code> and <code>ORDER BY</code> clauses.\nWith the default settings (i.e. the <code>returnAs</code> argument set to <code>object</code>), a model object will be returned if the record is found and the boolean value <code>false</code> if not.\nInstead of using the <code>where</code> argument, you can create cleaner code by making use of a concept called Dynamic Finders.",
    "body": [
      "findOne(where = ${1:\"\"}, order = ${2:\"\"}, select = ${3:\"\"}, include = ${4:\"\"}, handle = ${5:\"query\"}, cache = ${6:\"\"}, reload = ${7:\"\"}, parameterize = ${8:\"True\"}, returnAs = ${9:\"object\"}, includeSoftDeletes = ${10:\"false\"}, useIndex = ${11:\"\"}, dataSource = ${12:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "flash": {
    "prefix": "flash",
    "description": "The flash() function is used in controllers to access data stored in the Flash scope. Flash is a temporary storage mechanism that lets you persist values across the next request (often after a redirect). You can use it to retrieve a specific key or the entire Flash struct. If you pass in a key, it returns the value associated with it; if no key is passed, it returns all the Flash contents as a struct.",
    "body": [
      "flash()$0"
    ],
    "scope": "cfml"
  },
  "flash(allParams)": {
    "prefix": "flash",
    "description": "The flash() function is used in controllers to access data stored in the Flash scope. Flash is a temporary storage mechanism that lets you persist values across the next request (often after a redirect). You can use it to retrieve a specific key or the entire Flash struct. If you pass in a key, it returns the value associated with it; if no key is passed, it returns all the Flash contents as a struct.",
    "body": [
      "flash(key = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "flashClear": {
    "prefix": "flashClear",
    "description": "The flashClear() function removes all keys and values from the Flash scope. This is useful when you want to reset or clear out any temporary messages or data that were carried over from a previous request. After calling flashClear(), the Flash will be empty for the remainder of the request and any future requests until new values are inserted.",
    "body": [
      "flashClear()$0"
    ],
    "scope": "cfml"
  },
  "flashCount": {
    "prefix": "flashCount",
    "description": "The flashCount() function returns the number of keys currently stored in the Flash scope. This is useful to check whether there are any flash messages or temporary data before attempting to read or display them. It helps in conditionally rendering notifications or determining if the Flash is empty.",
    "body": [
      "flashCount()$0"
    ],
    "scope": "cfml"
  },
  "flashDelete": {
    "prefix": "flashDelete",
    "description": "The flashDelete() function removes a specific key from the Flash scope. It is useful when you want to delete a particular temporary message or piece of data without clearing the entire Flash. The function returns true if the key existed and was deleted, or false if the key was not present.",
    "body": [
      "flashDelete(key = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "flashInsert": {
    "prefix": "flashInsert",
    "description": "The flashInsert() function adds a new key-value pair to the Flash scope. This is useful for storing temporary messages or data that you want to persist across the next request, typically after a redirect. You can insert any type of value, such as strings, numbers, or structs, and later retrieve it using flash().",
    "body": [
      "flashInsert()$0"
    ],
    "scope": "cfml"
  },
  "flashIsEmpty": {
    "prefix": "flashIsEmpty",
    "description": "The flashIsEmpty() function checks whether the Flash scope contains any keys. It returns true if the Flash is empty and false if it contains one or more keys. This is useful for conditionally displaying messages or deciding whether to process Flash data before reading or clearing it.",
    "body": [
      "flashIsEmpty()$0"
    ],
    "scope": "cfml"
  },
  "flashKeep": {
    "prefix": "flashKeep",
    "description": "The flashKeep() function allows you to preserve Flash data for one additional request. By default, Flash values are only available for the very next request; calling flashKeep() prevents them from being cleared after the current request. You can choose to keep the entire Flash or only specific keys. This is useful when you want messages or temporary data to persist through multiple redirects or page loads.",
    "body": [
      "flashKeep()$0"
    ],
    "scope": "cfml"
  },
  "flashKeep(allParams)": {
    "prefix": "flashKeep",
    "description": "The flashKeep() function allows you to preserve Flash data for one additional request. By default, Flash values are only available for the very next request; calling flashKeep() prevents them from being cleared after the current request. You can choose to keep the entire Flash or only specific keys. This is useful when you want messages or temporary data to persist through multiple redirects or page loads.",
    "body": [
      "flashKeep(key = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "flashKeyExists": {
    "prefix": "flashKeyExists",
    "description": "The flashKeyExists() function checks whether a specific key is present in the Flash scope. It returns true if the key exists and false if it does not. This is useful for conditionally displaying or processing Flash messages or data before attempting to read them.",
    "body": [
      "flashKeyExists(key = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "flashMessages": {
    "prefix": "flashMessages",
    "description": "The flashMessages() function generates a formatted HTML output of messages stored in the Flash scope. It is typically used in views or layouts to display temporary notifications like success messages, alerts, or errors. You can choose to display all messages, a specific key, or multiple keys in a defined order. Additional options let you customize the container’s HTML class, include an empty container if no messages exist, and control whether the message content is URL-encoded.",
    "body": [
      "flashMessages()$0"
    ],
    "scope": "cfml"
  },
  "flashMessages(allParams)": {
    "prefix": "flashMessages",
    "description": "The flashMessages() function generates a formatted HTML output of messages stored in the Flash scope. It is typically used in views or layouts to display temporary notifications like success messages, alerts, or errors. You can choose to display all messages, a specific key, or multiple keys in a defined order. Additional options let you customize the container’s HTML class, include an empty container if no messages exist, and control whether the message content is URL-encoded.",
    "body": [
      "flashMessages(keys = ${1:\"\"}, class = ${2:\"flash-messages\"}, includeEmptyContainer = ${3:\"false\"}, encode = ${4:\"True\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "float": {
    "prefix": "float",
    "description": "The float() function is used in a table definition during a migration to add one or more float-type columns to a database table. You can specify column names, default values, and whether the columns allow NULL. This helps define numeric columns with decimal values in your schema. Only available in a migrator CFC.",
    "body": [
      "float()$0"
    ],
    "scope": "cfml"
  },
  "float(allParams)": {
    "prefix": "float",
    "description": "The float() function is used in a table definition during a migration to add one or more float-type columns to a database table. You can specify column names, default values, and whether the columns allow NULL. This helps define numeric columns with decimal values in your schema. Only available in a migrator CFC.",
    "body": [
      "float(columnNames = ${1:\"\"}, default = ${2:\"\"}, allowNull = ${3:\"true\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "get": {
    "prefix": "get",
    "description": "Returns the current value of a Wheels configuration setting or the default value for a specific function argument. It can be used to inspect global Wheels settings (like table name prefixes, pagination defaults, or other configuration values) or to check what the default argument would be for a particular Wheels function.",
    "body": [
      "get(name = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "get(allParams)": {
    "prefix": "get",
    "description": "Returns the current value of a Wheels configuration setting or the default value for a specific function argument. It can be used to inspect global Wheels settings (like table name prefixes, pagination defaults, or other configuration values) or to check what the default argument would be for a particular Wheels function.",
    "body": [
      "get(name = ${1:\"\"}, functionName = ${2:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "getAvailableMigrations": {
    "prefix": "getAvailableMigrations",
    "description": "The getAvailableMigrations() function scans the migration folder (by default /app/migrator/migrations/) and returns an array of all migration files it finds. Each item in the array contains information about the migration, including its version. While this function can be called from within your application, it is primarily intended for use via the Wheels CLI or GUI tools. It is useful for programmatically determining which migrations are available and what the latest migration version is.",
    "body": [
      "getAvailableMigrations()$0"
    ],
    "scope": "cfml"
  },
  "getAvailableMigrations(allParams)": {
    "prefix": "getAvailableMigrations",
    "description": "The getAvailableMigrations() function scans the migration folder (by default /app/migrator/migrations/) and returns an array of all migration files it finds. Each item in the array contains information about the migration, including its version. While this function can be called from within your application, it is primarily intended for use via the Wheels CLI or GUI tools. It is useful for programmatically determining which migrations are available and what the latest migration version is.",
    "body": [
      "getAvailableMigrations(path = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "getCurrentMigrationVersion": {
    "prefix": "getCurrentMigrationVersion",
    "description": "The getCurrentMigrationVersion() function returns the version number of the latest migration that has been applied to the database. This is useful for determining the current schema state programmatically, though it is primarily intended for use via the Wheels CLI or GUI interface. You can use this function within your application to perform conditional logic based on the database version or to verify that the database is up-to-date.",
    "body": [
      "getCurrentMigrationVersion()$0"
    ],
    "scope": "cfml"
  },
  "getEmails": {
    "prefix": "getEmails",
    "description": "Primarily used in testing scenarios to retrieve information about the emails that were sent during the current request. It returns an array containing details of all sent emails, which allows you to verify the content, recipients, and other properties of the emails in your automated tests. This is especially useful for unit or functional tests where you want to assert that specific emails are being triggered by certain actions without actually sending them.",
    "body": [
      "getEmails()$0"
    ],
    "scope": "cfml"
  },
  "getFiles": {
    "prefix": "getFiles",
    "description": "The getFiles() function is primarily used in testing scenarios to retrieve information about files sent during the current request. It returns an array containing details of all files handled in the request, such as uploaded attachments or generated files. This allows you to inspect and verify file-related operations in automated tests without needing to access the file system directly.",
    "body": [
      "getFiles()$0"
    ],
    "scope": "cfml"
  },
  "getRedirect": {
    "prefix": "getRedirect",
    "description": "Primarily used in testing scenarios to determine whether the current request has performed a redirect. It returns a structure containing information about the redirect, such as the target URL and the HTTP status code. This allows you to verify redirect behavior in automated tests without actually sending the user to another page.",
    "body": [
      "getRedirect()$0"
    ],
    "scope": "cfml"
  },
  "getRoutes": {
    "prefix": "getRoutes",
    "description": "Returns all the routes that have been defined in the application via the mapper() function. It provides a programmatic way to inspect the routing table, including route names, URL patterns, controllers, actions, and other metadata. This is useful for debugging, generating dynamic links, or performing logic based on the routes that exist in your application.",
    "body": [
      "getRoutes()$0"
    ],
    "scope": "cfml"
  },
  "getTableNamePrefix": {
    "prefix": "getTableNamePrefix",
    "description": "Returns the table name prefix that is set for the current model. This is useful when your database tables share a common prefix, and you need to construct queries dynamically or perform operations that require the full table name. By using this function, you ensure consistency and avoid hardcoding table prefixes in your queries.",
    "body": [
      "getTableNamePrefix()$0"
    ],
    "scope": "cfml"
  },
  "hasChanged": {
    "prefix": "hasChanged",
    "description": "Returns <code>true</code> if the specified property (or any if none was passed in) has been changed but not yet saved to the database.\nWill also return <code>true</code> if the object is new and no record for it exists in the database.",
    "body": [
      "hasChanged()$0"
    ],
    "scope": "cfml"
  },
  "hasChanged(allParams)": {
    "prefix": "hasChanged",
    "description": "Returns <code>true</code> if the specified property (or any if none was passed in) has been changed but not yet saved to the database.\nWill also return <code>true</code> if the object is new and no record for it exists in the database.",
    "body": [
      "hasChanged(property = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "hasErrors": {
    "prefix": "hasErrors",
    "description": "Checks whether a model object has any validation or other errors. It returns true if the object contains errors, or if a specific property or named error is provided, it checks only that subset. This is useful for validating objects before saving them to the database or displaying error messages to the user.",
    "body": [
      "hasErrors()$0"
    ],
    "scope": "cfml"
  },
  "hasErrors(allParams)": {
    "prefix": "hasErrors",
    "description": "Checks whether a model object has any validation or other errors. It returns true if the object contains errors, or if a specific property or named error is provided, it checks only that subset. This is useful for validating objects before saving them to the database or displaying error messages to the user.",
    "body": [
      "hasErrors(property = ${1:\"\"}, name = ${2:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "hasMany": {
    "prefix": "hasMany",
    "description": "Sets up a one-to-many association between the current model and another model. This allows you to easily fetch, join, and manage related records in a relational way while following Wheels conventions.",
    "body": [
      "hasMany(name = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "hasMany(allParams)": {
    "prefix": "hasMany",
    "description": "Sets up a one-to-many association between the current model and another model. This allows you to easily fetch, join, and manage related records in a relational way while following Wheels conventions.",
    "body": [
      "hasMany(name = ${1:\"\"}, modelName = ${2:\"\"}, foreignKey = ${3:\"\"}, joinKey = ${4:\"\"}, joinType = ${5:\"outer\"}, dependent = ${6:\"\"}, shortcut = ${7:\"\"}, through = ${8:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "hasManyCheckBox": {
    "prefix": "hasManyCheckBox",
    "description": "The hasManyCheckBox() helper generates the correct form elements for managing a hasMany or many-to-many association. It creates checkboxes for linking records together (e.g., a Book with many Authors).\nNote: Pass any additional arguments like class, rel, and id, and the generated tag will also include those values as HTML attributes.",
    "body": [
      "hasManyCheckBox(objectName = ${1:\"\"}, association = ${2:\"\"}, keys = ${3:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "hasManyCheckBox(allParams)": {
    "prefix": "hasManyCheckBox",
    "description": "The hasManyCheckBox() helper generates the correct form elements for managing a hasMany or many-to-many association. It creates checkboxes for linking records together (e.g., a Book with many Authors).\nNote: Pass any additional arguments like class, rel, and id, and the generated tag will also include those values as HTML attributes.",
    "body": [
      "hasManyCheckBox(objectName = ${1:\"\"}, association = ${2:\"\"}, keys = ${3:\"\"}, label = ${4:\"\"}, labelPlacement = ${5:\"\"}, prepend = ${6:\"\"}, append = ${7:\"\"}, prependToLabel = ${8:\"\"}, appendToLabel = ${9:\"\"}, errorElement = ${10:\"\"}, errorClass = ${11:\"\"}, encode = ${12:\"True\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "hasManyRadioButton": {
    "prefix": "hasManyRadioButton",
    "description": "This helper generates radio buttons for managing a hasMany or one-to-many association, where you want the user to pick one option (e.g., default address, primary contact method, preferred category).\nNote: Pass any additional arguments like class, rel, and id, and the generated tag will also include those values as HTML attributes.",
    "body": [
      "hasManyRadioButton(objectName = ${1:\"\"}, association = ${2:\"\"}, property = ${3:\"\"}, keys = ${4:\"\"}, tagValue = ${5:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "hasManyRadioButton(allParams)": {
    "prefix": "hasManyRadioButton",
    "description": "This helper generates radio buttons for managing a hasMany or one-to-many association, where you want the user to pick one option (e.g., default address, primary contact method, preferred category).\nNote: Pass any additional arguments like class, rel, and id, and the generated tag will also include those values as HTML attributes.",
    "body": [
      "hasManyRadioButton(objectName = ${1:\"\"}, association = ${2:\"\"}, property = ${3:\"\"}, keys = ${4:\"\"}, tagValue = ${5:\"\"}, checkIfBlank = ${6:\"\"}, label = ${7:\"\"}, encode = ${8:\"True\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "hasOne": {
    "prefix": "hasOne",
    "description": "Defines a one-to-one relationship between two models. It means each instance of this model is linked to exactly one record in another model. By default, Wheels infers table and key names, but you can customize them with arguments like foreignKey, joinKey, and joinType.",
    "body": [
      "hasOne(name = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "hasOne(allParams)": {
    "prefix": "hasOne",
    "description": "Defines a one-to-one relationship between two models. It means each instance of this model is linked to exactly one record in another model. By default, Wheels infers table and key names, but you can customize them with arguments like foreignKey, joinKey, and joinType.",
    "body": [
      "hasOne(name = ${1:\"\"}, modelName = ${2:\"\"}, foreignKey = ${3:\"\"}, joinKey = ${4:\"\"}, joinType = ${5:\"outer\"}, dependent = ${6:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "hasProperty": {
    "prefix": "hasProperty",
    "description": "Checks if a given property exists on a model object. It’s useful for safely validating whether a field is defined before accessing it, especially in dynamic code or when working with user input. This method also provides dynamic helpers (e.g., object.hasEmail()) for convenience.",
    "body": [
      "hasProperty(property = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "hiddenField": {
    "prefix": "hiddenField",
    "description": "The hiddenField() function generates a hidden &lt;input type=\"hidden\"&gt; tag for a given model object and property. It’s commonly used to store identifiers or other values that need to persist across form submissions without being visible to the user.\nNote: Pass any additional arguments like class, rel, and id, and the generated tag will also include those values as HTML attributes.",
    "body": [
      "hiddenField(objectName = ${1:\"\"}, property = ${2:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "hiddenField(allParams)": {
    "prefix": "hiddenField",
    "description": "The hiddenField() function generates a hidden &lt;input type=\"hidden\"&gt; tag for a given model object and property. It’s commonly used to store identifiers or other values that need to persist across form submissions without being visible to the user.\nNote: Pass any additional arguments like class, rel, and id, and the generated tag will also include those values as HTML attributes.",
    "body": [
      "hiddenField(objectName = ${1:\"\"}, property = ${2:\"\"}, association = ${3:\"\"}, position = ${4:\"\"}, encode = ${5:\"True\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "hiddenFieldTag": {
    "prefix": "hiddenFieldTag",
    "description": "Generates a hidden &lt;input type=\"hidden\"&gt; tag using a plain name/value pair. Unlike hiddenField(), this helper does not tie to a model object — it’s meant for raw form fields where you control the name and value manually.\nNote: Pass any additional arguments like <code>class</code>, <code>rel</code>, and <code>id</code>, and the generated tag will also include those values as HTML attributes.",
    "body": [
      "hiddenFieldTag(name = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "hiddenFieldTag(allParams)": {
    "prefix": "hiddenFieldTag",
    "description": "Generates a hidden &lt;input type=\"hidden\"&gt; tag using a plain name/value pair. Unlike hiddenField(), this helper does not tie to a model object — it’s meant for raw form fields where you control the name and value manually.\nNote: Pass any additional arguments like <code>class</code>, <code>rel</code>, and <code>id</code>, and the generated tag will also include those values as HTML attributes.",
    "body": [
      "hiddenFieldTag(name = ${1:\"\"}, value = ${2:\"\"}, encode = ${3:\"True\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "highlight": {
    "prefix": "highlight",
    "description": "Searches the given text for one or more phrases and wraps all matches in an HTML tag (default: &lt;span&gt;). This is useful for search results or emphasizing certain keywords dynamically.",
    "body": [
      "highlight(text = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "highlight(allParams)": {
    "prefix": "highlight",
    "description": "Searches the given text for one or more phrases and wraps all matches in an HTML tag (default: &lt;span&gt;). This is useful for search results or emphasizing certain keywords dynamically.",
    "body": [
      "highlight(text = ${1:\"\"}, phrase = ${2:\"\"}, delimiter = ${3:\",\"}, tag = ${4:\"span\"}, class = ${5:\"highlight\"}, encode = ${6:\"True\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "hourSelectTag": {
    "prefix": "hourSelectTag",
    "description": "Builds and returns a &lt;select&gt; form control for choosing an hour of the day. By default, hours are shown in 24-hour format (00–23), but you can switch to 12-hour format with an accompanying AM/PM dropdown.",
    "body": [
      "hourSelectTag(name = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "hourSelectTag(allParams)": {
    "prefix": "hourSelectTag",
    "description": "Builds and returns a &lt;select&gt; form control for choosing an hour of the day. By default, hours are shown in 24-hour format (00–23), but you can switch to 12-hour format with an accompanying AM/PM dropdown.",
    "body": [
      "hourSelectTag(name = ${1:\"\"}, selected = ${2:\"\"}, includeBlank = ${3:\"\"}, label = ${4:\"\"}, labelPlacement = ${5:\"around\"}, prepend = ${6:\"\"}, append = ${7:\"\"}, prependToLabel = ${8:\"\"}, appendToLabel = ${9:\"\"}, twelveHour = ${10:\"\"}, encode = ${11:\"True\"}, $now = ${12:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "humanize": {
    "prefix": "humanize",
    "description": "Converts a camel-cased or underscored string into more readable, human-friendly text by inserting spaces and capitalizing words. You can also specify words that should be replaced or kept in a specific format.",
    "body": [
      "humanize(text = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "humanize(allParams)": {
    "prefix": "humanize",
    "description": "Converts a camel-cased or underscored string into more readable, human-friendly text by inserting spaces and capitalizing words. You can also specify words that should be replaced or kept in a specific format.",
    "body": [
      "humanize(text = ${1:\"\"}, except = ${2:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "hyphenize": {
    "prefix": "hyphenize",
    "description": "Converts camelCase or PascalCase strings into lowercase hyphen-separated strings. Useful for generating URL-friendly slugs, CSS class names, or readable identifiers.",
    "body": [
      "hyphenize(string = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "imageTag": {
    "prefix": "imageTag",
    "description": "Returns an <code>img</code> tag.\nIf the image is stored in the local <code>images</code> folder, the tag will also set the <code>width</code>, <code>height</code>, and <code>alt</code> attributes for you.\nYou can pass any additional arguments (e.g. <code>class</code>, <code>rel</code>, <code>id</code>), and the generated tag will also include those values as HTML attributes.",
    "body": [
      "imageTag(source = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "imageTag(allParams)": {
    "prefix": "imageTag",
    "description": "Returns an <code>img</code> tag.\nIf the image is stored in the local <code>images</code> folder, the tag will also set the <code>width</code>, <code>height</code>, and <code>alt</code> attributes for you.\nYou can pass any additional arguments (e.g. <code>class</code>, <code>rel</code>, <code>id</code>), and the generated tag will also include those values as HTML attributes.",
    "body": [
      "imageTag(source = ${1:\"\"}, onlyPath = ${2:\"True\"}, host = ${3:\"\"}, protocol = ${4:\"\"}, port = ${5:\"\"}, encode = ${6:\"True\"}, required = ${7:\"True\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "includeContent": {
    "prefix": "includeContent",
    "description": "Outputs the content for a specific section in a layout. Works together with contentFor() to define and then inject content into layouts. Typically used for head, sidebar, footer, or other pluggable layout sections. If the requested section hasn’t been defined, it will either return nothing or the provided defaultValue.",
    "body": [
      "includeContent()$0"
    ],
    "scope": "cfml"
  },
  "includeContent(allParams)": {
    "prefix": "includeContent",
    "description": "Outputs the content for a specific section in a layout. Works together with contentFor() to define and then inject content into layouts. Typically used for head, sidebar, footer, or other pluggable layout sections. If the requested section hasn’t been defined, it will either return nothing or the provided defaultValue.",
    "body": [
      "includeContent(name = ${1:\"body\"}, defaultValue = ${2:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "includedInObject": {
    "prefix": "includedInObject",
    "description": "Used as a shortcut to check if the specified IDs are a part of the main form object.\nThis method should only be used for <code>hasMany</code> associations.",
    "body": [
      "includedInObject(objectName = ${1:\"\"}, association = ${2:\"\"}, keys = ${3:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "includeLayout": {
    "prefix": "includeLayout",
    "description": "Includes the contents of another layout file. Typically used when a child layout wants to include a parent layout, or to nest layouts for consistent site structure.",
    "body": [
      "includeLayout()$0"
    ],
    "scope": "cfml"
  },
  "includeLayout(allParams)": {
    "prefix": "includeLayout",
    "description": "Includes the contents of another layout file. Typically used when a child layout wants to include a parent layout, or to nest layouts for consistent site structure.",
    "body": [
      "includeLayout(name = ${1:\"layout\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "includePartial": {
    "prefix": "includePartial",
    "description": "Includes the specified partial file in the view.\nSimilar to using <code>cfinclude</code> but with the ability to cache the result and use Wheels-specific file look-up.\nBy default, Wheels will look for the file in the current controller's view folder.\nTo include a file relative from the base <code>views</code> folder, you can start the path supplied to <code>partial</code> with a forward slash.",
    "body": [
      "includePartial(partial = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "includePartial(allParams)": {
    "prefix": "includePartial",
    "description": "Includes the specified partial file in the view.\nSimilar to using <code>cfinclude</code> but with the ability to cache the result and use Wheels-specific file look-up.\nBy default, Wheels will look for the file in the current controller's view folder.\nTo include a file relative from the base <code>views</code> folder, you can start the path supplied to <code>partial</code> with a forward slash.",
    "body": [
      "includePartial(partial = ${1:\"\"}, group = ${2:\"\"}, cache = ${3:\"\"}, layout = ${4:\"\"}, spacer = ${5:\"\"}, dataFunction = ${6:\"True\"}, $prependWithUnderscore = ${7:\"True\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "integer": {
    "prefix": "integer",
    "description": "Adds one or more integer columns to a table definition during a migration. You can optionally specify a limit, default value, and whether the column allows NULL. Only available in migrator CFC.",
    "body": [
      "integer()$0"
    ],
    "scope": "cfml"
  },
  "integer(allParams)": {
    "prefix": "integer",
    "description": "Adds one or more integer columns to a table definition during a migration. You can optionally specify a limit, default value, and whether the column allows NULL. Only available in migrator CFC.",
    "body": [
      "integer(columnNames = ${1:\"\"}, limit = ${2:\"\"}, default = ${3:\"\"}, allowNull = ${4:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "invokeWithTransaction": {
    "prefix": "invokeWithTransaction",
    "description": "Runs a specified model method inside a single database transaction. This ensures that all database operations within the method are treated as a single atomic unit: either all succeed or all fail.",
    "body": [
      "invokeWithTransaction(method = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "invokeWithTransaction(allParams)": {
    "prefix": "invokeWithTransaction",
    "description": "Runs a specified model method inside a single database transaction. This ensures that all database operations within the method are treated as a single atomic unit: either all succeed or all fail.",
    "body": [
      "invokeWithTransaction(method = ${1:\"\"}, transaction = ${2:\"commit\"}, isolation = ${3:\"read_committed\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "isAjax": {
    "prefix": "isAjax",
    "description": "Checks if the current request was made via JavaScript (AJAX) rather than a standard browser page load. This is useful when you want to return JSON or partial content instead of a full HTML page.",
    "body": [
      "isAjax()$0"
    ],
    "scope": "cfml"
  },
  "isClass": {
    "prefix": "isClass",
    "description": "Determines whether the method is being called at the class level (on the model itself) or on an instance of the model. This is useful when the same function can be invoked either on a model object or directly on the model class.",
    "body": [
      "isClass()$0"
    ],
    "scope": "cfml"
  },
  "isDelete": {
    "prefix": "isDelete",
    "description": "Checks if the current HTTP request method is DELETE. This is useful for RESTful controllers where different logic is executed based on the request type.",
    "body": [
      "isDelete()$0"
    ],
    "scope": "cfml"
  },
  "isGet": {
    "prefix": "isGet",
    "description": "Checks if the current HTTP request method is GET. Useful for controlling logic depending on whether a page is being displayed or data is being requested via GET.",
    "body": [
      "isGet()$0"
    ],
    "scope": "cfml"
  },
  "isHead": {
    "prefix": "isHead",
    "description": "Checks if the current HTTP request method is HEAD. HEAD requests are similar to GET requests but do not return a message body, only the headers. This is often used for checking metadata like content length or existence without transferring the actual content.",
    "body": [
      "isHead()$0"
    ],
    "scope": "cfml"
  },
  "isInstance": {
    "prefix": "isInstance",
    "description": "Checks whether the current context is an instance of a model object rather than a class-level context. This is useful when a method could be called either on a class or an instance, and you want to behave differently depending on which it is.",
    "body": [
      "isInstance()$0"
    ],
    "scope": "cfml"
  },
  "isNew": {
    "prefix": "isNew",
    "description": "Returns <code>true</code> if this object hasn't been saved yet (in other words, no matching record exists in the database yet).\nReturns <code>false</code> if a record exists.",
    "body": [
      "isNew()$0"
    ],
    "scope": "cfml"
  },
  "isOptions": {
    "prefix": "isOptions",
    "description": "Checks whether the current HTTP request was made using the OPTIONS method. Useful in REST APIs or CORS preflight requests.",
    "body": [
      "isOptions()$0"
    ],
    "scope": "cfml"
  },
  "isPatch": {
    "prefix": "isPatch",
    "description": "Checks whether the current HTTP request was made using the PATCH method. Useful when building RESTful APIs where PATCH is used to partially update resources.",
    "body": [
      "isPatch()$0"
    ],
    "scope": "cfml"
  },
  "isPersisted": {
    "prefix": "isPersisted",
    "description": "Returns <code>true</code> if this object has been persisted to the database or was loaded from the database via a finder.\nReturns <code>false</code> if the record has not been persisted to the database.",
    "body": [
      "isPersisted()$0"
    ],
    "scope": "cfml"
  },
  "isPost": {
    "prefix": "isPost",
    "description": "Returns whether the request came from a form <code>POST</code> submission or not.",
    "body": [
      "isPost()$0"
    ],
    "scope": "cfml"
  },
  "isPut": {
    "prefix": "isPut",
    "description": "Checks whether the current HTTP request is a PUT request. PUT requests are typically used to update existing resources in RESTful APIs.",
    "body": [
      "isPut()$0"
    ],
    "scope": "cfml"
  },
  "isSecure": {
    "prefix": "isSecure",
    "description": "Checks whether the current request is made over a secure connection (HTTPS). Returns true if the connection is secure, otherwise false.",
    "body": [
      "isSecure()$0"
    ],
    "scope": "cfml"
  },
  "javaScriptIncludeTag": {
    "prefix": "javaScriptIncludeTag",
    "description": "Generates &lt;script&gt; tags for including JavaScript files. Can handle local files in the javascripts folder or external URLs. Supports multiple files and optional placement in the HTML &lt;head&gt;.",
    "body": [
      "javaScriptIncludeTag()$0"
    ],
    "scope": "cfml"
  },
  "javaScriptIncludeTag(allParams)": {
    "prefix": "javaScriptIncludeTag",
    "description": "Generates &lt;script&gt; tags for including JavaScript files. Can handle local files in the javascripts folder or external URLs. Supports multiple files and optional placement in the HTML &lt;head&gt;.",
    "body": [
      "javaScriptIncludeTag(sources = ${1:\"\"}, type = ${2:\"text/javascript\"}, head = ${3:\"\"}, delim = ${4:\",\"}, encode = ${5:\"True\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "key": {
    "prefix": "key",
    "description": "Returns the value of the primary key for the object.\nIf you have a single primary key named id, then <code>someObject.key()</code> is functionally equivalent to <code>someObject.id</code>.\nThis method is more useful when you do dynamic programming and don't know the name of the primary key or when you use composite keys (in which case it's convenient to use this method to get a list of both key values returned).",
    "body": [
      "key()$0"
    ],
    "scope": "cfml"
  },
  "key(allParams)": {
    "prefix": "key",
    "description": "Returns the value of the primary key for the object.\nIf you have a single primary key named id, then <code>someObject.key()</code> is functionally equivalent to <code>someObject.id</code>.\nThis method is more useful when you do dynamic programming and don't know the name of the primary key or when you use composite keys (in which case it's convenient to use this method to get a list of both key values returned).",
    "body": [
      "key($persisted = ${1:\"\"}, $returnTickCountWhenNew = ${2:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "linkTo": {
    "prefix": "linkTo",
    "description": "Creates a link to another page in your application.\nPass in the name of a route to use your configured routes or a controller/action/key combination.\nNote: Pass any additional arguments like class, rel, and id, and the generated tag will also include those values as HTML attributes.",
    "body": [
      "linkTo()$0"
    ],
    "scope": "cfml"
  },
  "linkTo(allParams)": {
    "prefix": "linkTo",
    "description": "Creates a link to another page in your application.\nPass in the name of a route to use your configured routes or a controller/action/key combination.\nNote: Pass any additional arguments like class, rel, and id, and the generated tag will also include those values as HTML attributes.",
    "body": [
      "linkTo(text = ${1:\"\"}, route = ${2:\"\"}, controller = ${3:\"\"}, action = ${4:\"\"}, key = ${5:\"\"}, params = ${6:\"\"}, anchor = ${7:\"\"}, onlyPath = ${8:\"True\"}, host = ${9:\"\"}, protocol = ${10:\"\"}, port = ${11:\"\"}, href = ${12:\"\"}, encode = ${13:\"True\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "mailTo": {
    "prefix": "mailTo",
    "description": "Creates a <code>mailto</code> link tag to the specified email address, which is also used as the name of the link unless name is specified.",
    "body": [
      "mailTo(emailAddress = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "mailTo(allParams)": {
    "prefix": "mailTo",
    "description": "Creates a <code>mailto</code> link tag to the specified email address, which is also used as the name of the link unless name is specified.",
    "body": [
      "mailTo(emailAddress = ${1:\"\"}, name = ${2:\"\"}, encode = ${3:\"True\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "mapper": {
    "prefix": "mapper",
    "description": "Returns the mapper object used to configure your application's routes. Usually you will use this method in <code>app/config/routes.cfm</code> to start chaining route mapping methods like <code>resources</code>, <code>namespace</code>, etc.",
    "body": [
      "mapper()$0"
    ],
    "scope": "cfml"
  },
  "mapper(allParams)": {
    "prefix": "mapper",
    "description": "Returns the mapper object used to configure your application's routes. Usually you will use this method in <code>app/config/routes.cfm</code> to start chaining route mapping methods like <code>resources</code>, <code>namespace</code>, etc.",
    "body": [
      "mapper(restful = ${1:\"True\"}, methods = ${2:\"\"}, mapFormat = ${3:\"True\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "maximum": {
    "prefix": "maximum",
    "description": "Calculates the maximum value for a given property.\nUses the SQL function <code>MAX</code>.\nIf no records can be found to perform the calculation on you can use the <code>ifNull</code> argument to decide what should be returned.",
    "body": [
      "maximum(property = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "maximum(allParams)": {
    "prefix": "maximum",
    "description": "Calculates the maximum value for a given property.\nUses the SQL function <code>MAX</code>.\nIf no records can be found to perform the calculation on you can use the <code>ifNull</code> argument to decide what should be returned.",
    "body": [
      "maximum(property = ${1:\"\"}, where = ${2:\"\"}, include = ${3:\"\"}, parameterize = ${4:\"True\"}, ifNull = ${5:\"\"}, includeSoftDeletes = ${6:\"false\"}, group = ${7:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "member": {
    "prefix": "member",
    "description": "Scope routes within a nested resource which require use of the primary key as part of the URL pattern;\nA member route will require an ID, because it acts on a member.\nphotos/1/preview is an example of a member route, because it acts on (and displays) a single object.",
    "body": [
      "member()$0"
    ],
    "scope": "cfml"
  },
  "migrateTo": {
    "prefix": "migrateTo",
    "description": "Migrates the database schema to a specified version. This function is primarily intended for programmatic database migrations, but the recommended usage is via the CLI or Wheels GUI interface.",
    "body": [
      "migrateTo()$0"
    ],
    "scope": "cfml"
  },
  "migrateTo(allParams)": {
    "prefix": "migrateTo",
    "description": "Migrates the database schema to a specified version. This function is primarily intended for programmatic database migrations, but the recommended usage is via the CLI or Wheels GUI interface.",
    "body": [
      "migrateTo(version = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "migrateToLatest": {
    "prefix": "migrateToLatest",
    "description": "Migrates the database schema to the latest available migration version. This is a shortcut for migrateTo(version) without needing to specify a version explicitly.",
    "body": [
      "migrateToLatest()$0"
    ],
    "scope": "cfml"
  },
  "mimeTypes": {
    "prefix": "mimeTypes",
    "description": "Returns the associated MIME type for a given file extension. Useful when serving files dynamically or setting response headers.",
    "body": [
      "mimeTypes(extension = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "mimeTypes(allParams)": {
    "prefix": "mimeTypes",
    "description": "Returns the associated MIME type for a given file extension. Useful when serving files dynamically or setting response headers.",
    "body": [
      "mimeTypes(extension = ${1:\"\"}, fallback = ${2:\"application/octet-stream\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "minimum": {
    "prefix": "minimum",
    "description": "Calculates the minimum value for a specified property in a model using SQL's MIN() function. This can be used to find the lowest value of a numeric property across all records or with conditions. You can also include associations, handle soft-deleted records, provide fallback values, and group results. If no records can be found to perform the calculation on you can use the <code>ifNull</code> argument to decide what should be returned.",
    "body": [
      "minimum(property = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "minimum(allParams)": {
    "prefix": "minimum",
    "description": "Calculates the minimum value for a specified property in a model using SQL's MIN() function. This can be used to find the lowest value of a numeric property across all records or with conditions. You can also include associations, handle soft-deleted records, provide fallback values, and group results. If no records can be found to perform the calculation on you can use the <code>ifNull</code> argument to decide what should be returned.",
    "body": [
      "minimum(property = ${1:\"\"}, where = ${2:\"\"}, include = ${3:\"\"}, parameterize = ${4:\"True\"}, ifNull = ${5:\"\"}, includeSoftDeletes = ${6:\"false\"}, group = ${7:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "minuteSelectTag": {
    "prefix": "minuteSelectTag",
    "description": "Builds and returns a &lt;select&gt; dropdown for the minutes of an hour (0–59). You can customize the selected value, increment steps (e.g., 5, 10, 15 minutes), label placement, and include a blank option. Useful for forms where users pick a time.",
    "body": [
      "minuteSelectTag(name = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "minuteSelectTag(allParams)": {
    "prefix": "minuteSelectTag",
    "description": "Builds and returns a &lt;select&gt; dropdown for the minutes of an hour (0–59). You can customize the selected value, increment steps (e.g., 5, 10, 15 minutes), label placement, and include a blank option. Useful for forms where users pick a time.",
    "body": [
      "minuteSelectTag(name = ${1:\"\"}, selected = ${2:\"\"}, minuteStep = ${3:\"1\"}, includeBlank = ${4:\"\"}, label = ${5:\"\"}, labelPlacement = ${6:\"around\"}, prepend = ${7:\"\"}, append = ${8:\"\"}, prependToLabel = ${9:\"\"}, appendToLabel = ${10:\"\"}, encode = ${11:\"True\"}, $now = ${12:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "model": {
    "prefix": "model",
    "description": "Returns a reference to a specific model defined in your application, allowing you to call class-level methods on it. This is useful when you want to access database records or invoke model methods without instantiating a new object first.",
    "body": [
      "model(name = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "monthSelectTag": {
    "prefix": "monthSelectTag",
    "description": "Generates a &lt;select&gt; dropdown for selecting a month. You can customize its options, labels, and display format. Unlike dateSelect, this function focuses only on the month portion.",
    "body": [
      "monthSelectTag(name = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "monthSelectTag(allParams)": {
    "prefix": "monthSelectTag",
    "description": "Generates a &lt;select&gt; dropdown for selecting a month. You can customize its options, labels, and display format. Unlike dateSelect, this function focuses only on the month portion.",
    "body": [
      "monthSelectTag(name = ${1:\"\"}, selected = ${2:\"\"}, monthDisplay = ${3:\"names\"}, monthNames = ${4:\"January,February,March,April,May,June,July,August,September,October,November,December\"}, monthAbbreviations = ${5:\"Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec\"}, includeBlank = ${6:\"\"}, label = ${7:\"\"}, labelPlacement = ${8:\"around\"}, prepend = ${9:\"\"}, append = ${10:\"\"}, prependToLabel = ${11:\"\"}, appendToLabel = ${12:\"\"}, encode = ${13:\"True\"}, $now = ${14:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "namespace": {
    "prefix": "namespace",
    "description": "The namespace() function in Wheels is used to group controllers and routes under a specific namespace (subfolder/package). It also prepends the namespace to route names and can modify the URL path. This is useful for organizing APIs, versioning, or modular applications. Namespaces can be nested for hierarchical routing, e.g., /api/v1/... and /api/v2/....",
    "body": [
      "namespace(name = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "namespace(allParams)": {
    "prefix": "namespace",
    "description": "The namespace() function in Wheels is used to group controllers and routes under a specific namespace (subfolder/package). It also prepends the namespace to route names and can modify the URL path. This is useful for organizing APIs, versioning, or modular applications. Namespaces can be nested for hierarchical routing, e.g., /api/v1/... and /api/v2/....",
    "body": [
      "namespace(name = ${1:\"\"}, package = ${2:\"\"}, path = ${3:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "nestedProperties": {
    "prefix": "nestedProperties",
    "description": "Allows nested objects, arrays, or structs associated with a model to be automatically set from incoming params or other generated data. This is particularly useful when you have hasMany or belongsTo associations and want to manage them directly when saving the parent object.",
    "body": [
      "nestedProperties()$0"
    ],
    "scope": "cfml"
  },
  "nestedProperties(allParams)": {
    "prefix": "nestedProperties",
    "description": "Allows nested objects, arrays, or structs associated with a model to be automatically set from incoming params or other generated data. This is particularly useful when you have hasMany or belongsTo associations and want to manage them directly when saving the parent object.",
    "body": [
      "nestedProperties(association = ${1:\"\"}, autoSave = ${2:\"True\"}, allowDelete = ${3:\"\"}, sortProperty = ${4:\"\"}, rejectIfBlank = ${5:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "new": {
    "prefix": "new",
    "description": "Creates a new object based on supplied <code>properties</code> and returns it.\nThe object is not saved to the database, it only exists in memory.\nProperty names and values can be passed in either using named arguments or as a struct to the <code>properties</code> argument.",
    "body": [
      "new()$0"
    ],
    "scope": "cfml"
  },
  "new(allParams)": {
    "prefix": "new",
    "description": "Creates a new object based on supplied <code>properties</code> and returns it.\nThe object is not saved to the database, it only exists in memory.\nProperty names and values can be passed in either using named arguments or as a struct to the <code>properties</code> argument.",
    "body": [
      "new(properties = ${1:\"\"}, callbacks = ${2:\"True\"}, allowExplicitTimestamps = ${3:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "obfuscateParam": {
    "prefix": "obfuscateParam",
    "description": "Obfuscates a value, typically used to hide sensitive information like primary key IDs when passing them in URLs. This helps prevent users from easily guessing sequential IDs or sensitive values.",
    "body": [
      "obfuscateParam(param = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "onlyProvides": {
    "prefix": "onlyProvides",
    "description": "Use this in an individual controller action to define which formats the action will respond with.\nThis can be used to define provides behavior in individual actions or to override a global setting set with <code>provides</code> in the controller's <code>config()</code>.",
    "body": [
      "onlyProvides()$0"
    ],
    "scope": "cfml"
  },
  "onlyProvides(allParams)": {
    "prefix": "onlyProvides",
    "description": "Use this in an individual controller action to define which formats the action will respond with.\nThis can be used to define provides behavior in individual actions or to override a global setting set with <code>provides</code> in the controller's <code>config()</code>.",
    "body": [
      "onlyProvides(formats = ${1:\"\"}, action = ${2:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "onMissingMethod": {
    "prefix": "onMissingMethod",
    "description": "This method is not designed to be called directly from your code, but provides functionality for dynamic finders such as <code>findOneByEmail()</code>",
    "body": [
      "onMissingMethod(missingMethodName = ${1:\"\"}, missingMethodArguments = ${2:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "package": {
    "prefix": "package",
    "description": "Scopes the controllers for any routes defined inside its block to a specific subfolder (package) without adding the package name to the URL. This is useful for organizing your controllers in subfolders while keeping the URL structure clean.",
    "body": [
      "package(name = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "package(allParams)": {
    "prefix": "package",
    "description": "Scopes the controllers for any routes defined inside its block to a specific subfolder (package) without adding the package name to the URL. This is useful for organizing your controllers in subfolders while keeping the URL structure clean.",
    "body": [
      "package(name = ${1:\"\"}, package = ${2:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "packageSetup": {
    "prefix": "packageSetup",
    "description": "The packageSetup() function is a callback in Wheels’ legacy testing framework. It runs once before the first test case in the test package. Use it to perform setup tasks that are shared across all tests in the package, such as initializing data, creating test records, or configuring environment settings.",
    "body": [
      "packageSetup()$0"
    ],
    "scope": "cfml"
  },
  "packageTeardown": {
    "prefix": "packageTeardown",
    "description": "The packageTeardown() function is a callback in Wheels’ legacy testing framework. It runs once after the last test case in the test package. Use it to perform cleanup tasks that are shared across all tests in the package, such as deleting test records, resetting application state, or clearing cached data.",
    "body": [
      "packageTeardown()$0"
    ],
    "scope": "cfml"
  },
  "pagination": {
    "prefix": "pagination",
    "description": "Returns a struct with information about the specificed paginated query.\nThe keys that will be included in the struct are <code>currentPage</code>, <code>totalPages</code> and <code>totalRecords</code>.",
    "body": [
      "pagination()$0"
    ],
    "scope": "cfml"
  },
  "pagination(allParams)": {
    "prefix": "pagination",
    "description": "Returns a struct with information about the specificed paginated query.\nThe keys that will be included in the struct are <code>currentPage</code>, <code>totalPages</code> and <code>totalRecords</code>.",
    "body": [
      "pagination(handle = ${1:\"query\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "paginationLinks": {
    "prefix": "paginationLinks",
    "description": "Builds and returns a string containing links to pages based on a paginated query.\nUses <code>linkTo()</code> internally to build the link, so you need to pass in a route name or a controller/action/key combination.\nAll other <code>linkTo()</code> arguments can be supplied as well, in which case they are passed through directly to <code>linkTo()</code>.\nIf you have paginated more than one query in the controller, you can use the handle argument to reference them. (Don't forget to pass in a handle to the <code>findAll()</code> function in your controller first.)",
    "body": [
      "paginationLinks()$0"
    ],
    "scope": "cfml"
  },
  "paginationLinks(allParams)": {
    "prefix": "paginationLinks",
    "description": "Builds and returns a string containing links to pages based on a paginated query.\nUses <code>linkTo()</code> internally to build the link, so you need to pass in a route name or a controller/action/key combination.\nAll other <code>linkTo()</code> arguments can be supplied as well, in which case they are passed through directly to <code>linkTo()</code>.\nIf you have paginated more than one query in the controller, you can use the handle argument to reference them. (Don't forget to pass in a handle to the <code>findAll()</code> function in your controller first.)",
    "body": [
      "paginationLinks(windowSize = ${1:\"2\"}, alwaysShowAnchors = ${2:\"True\"}, anchorDivider = ${3:\" ... \"}, linkToCurrentPage = ${4:\"\"}, prepend = ${5:\"\"}, append = ${6:\"\"}, prependToPage = ${7:\"\"}, addActiveClassToPrependedParent = ${8:\"\"}, prependOnFirst = ${9:\"True\"}, prependOnAnchor = ${10:\"True\"}, appendToPage = ${11:\"\"}, appendOnLast = ${12:\"True\"}, appendOnAnchor = ${13:\"True\"}, classForCurrent = ${14:\"\"}, handle = ${15:\"query\"}, name = ${16:\"page\"}, showSinglePage = ${17:\"\"}, pageNumberAsParam = ${18:\"True\"}, encode = ${19:\"True\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "passwordField": {
    "prefix": "passwordField",
    "description": "Builds and returns a string containing a password field form control based on the supplied objectName and property.\nNote: Pass any additional arguments like class, rel, and id, and the generated tag will also include those values as HTML attributes.",
    "body": [
      "passwordField(objectName = ${1:\"\"}, property = ${2:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "passwordField(allParams)": {
    "prefix": "passwordField",
    "description": "Builds and returns a string containing a password field form control based on the supplied objectName and property.\nNote: Pass any additional arguments like class, rel, and id, and the generated tag will also include those values as HTML attributes.",
    "body": [
      "passwordField(objectName = ${1:\"\"}, property = ${2:\"\"}, association = ${3:\"\"}, position = ${4:\"\"}, label = ${5:\"useDefaultLabel\"}, labelPlacement = ${6:\"around\"}, prepend = ${7:\"\"}, append = ${8:\"\"}, prependToLabel = ${9:\"\"}, appendToLabel = ${10:\"\"}, errorElement = ${11:\"span\"}, errorClass = ${12:\"field-with-errors\"}, encode = ${13:\"True\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "passwordFieldTag": {
    "prefix": "passwordFieldTag",
    "description": "Builds and returns a string containing a password field form control based on the supplied name.\nNote: Pass any additional arguments like <code>class</code>, <code>rel</code>, and <code>id</code>, and the generated tag will also include those values as HTML attributes.",
    "body": [
      "passwordFieldTag(name = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "passwordFieldTag(allParams)": {
    "prefix": "passwordFieldTag",
    "description": "Builds and returns a string containing a password field form control based on the supplied name.\nNote: Pass any additional arguments like <code>class</code>, <code>rel</code>, and <code>id</code>, and the generated tag will also include those values as HTML attributes.",
    "body": [
      "passwordFieldTag(name = ${1:\"\"}, value = ${2:\"\"}, label = ${3:\"\"}, labelPlacement = ${4:\"around\"}, prepend = ${5:\"\"}, append = ${6:\"\"}, prependToLabel = ${7:\"\"}, appendToLabel = ${8:\"\"}, encode = ${9:\"True\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "patch": {
    "prefix": "patch",
    "description": "Create a route that matches a URL requiring an HTTP <code>PATCH</code> method. We recommend using this matcher to expose actions that update database records.",
    "body": [
      "patch()$0"
    ],
    "scope": "cfml"
  },
  "patch(allParams)": {
    "prefix": "patch",
    "description": "Create a route that matches a URL requiring an HTTP <code>PATCH</code> method. We recommend using this matcher to expose actions that update database records.",
    "body": [
      "patch(name = ${1:\"\"}, pattern = ${2:\"\"}, to = ${3:\"\"}, controller = ${4:\"\"}, action = ${5:\"\"}, package = ${6:\"\"}, on = ${7:\"\"}, redirect = ${8:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "pluginNames": {
    "prefix": "pluginNames",
    "description": "Returns a list of all installed Wheels plugins in your application. This can be useful if you want to check for the presence of a plugin before calling its functionality, or to display available plugins dynamically.",
    "body": [
      "pluginNames()$0"
    ],
    "scope": "cfml"
  },
  "pluralize": {
    "prefix": "pluralize",
    "description": "Returns the plural form of the passed in word. Can also pluralize a word based on a value passed to the <code>count</code> argument. Wheels stores a list of words that are the same in both singular and plural form (e.g. \"equipment\", \"information\") and words that don't follow the regular pluralization rules (e.g. \"child\" / \"children\", \"foot\" / \"feet\"). Use <code>get(\"uncountables\")</code> / <code>set(\"uncountables\", newList)</code> and <code>get(\"irregulars\")</code> / <code>set(\"irregulars\", newList)</code> to modify them to suit your needs.",
    "body": [
      "pluralize(word = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "pluralize(allParams)": {
    "prefix": "pluralize",
    "description": "Returns the plural form of the passed in word. Can also pluralize a word based on a value passed to the <code>count</code> argument. Wheels stores a list of words that are the same in both singular and plural form (e.g. \"equipment\", \"information\") and words that don't follow the regular pluralization rules (e.g. \"child\" / \"children\", \"foot\" / \"feet\"). Use <code>get(\"uncountables\")</code> / <code>set(\"uncountables\", newList)</code> and <code>get(\"irregulars\")</code> / <code>set(\"irregulars\", newList)</code> to modify them to suit your needs.",
    "body": [
      "pluralize(word = ${1:\"\"}, count = ${2:\"-1\"}, returnCount = ${3:\"true\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "post": {
    "prefix": "post",
    "description": "Create a route that matches a URL requiring an HTTP <code>POST</code> method. We recommend using this matcher to expose actions that create database records.",
    "body": [
      "post()$0"
    ],
    "scope": "cfml"
  },
  "post(allParams)": {
    "prefix": "post",
    "description": "Create a route that matches a URL requiring an HTTP <code>POST</code> method. We recommend using this matcher to expose actions that create database records.",
    "body": [
      "post(name = ${1:\"\"}, pattern = ${2:\"\"}, to = ${3:\"\"}, controller = ${4:\"\"}, action = ${5:\"\"}, package = ${6:\"\"}, on = ${7:\"\"}, redirect = ${8:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "primaryKey": {
    "prefix": "primaryKey",
    "description": "Used inside migration table definitions to define a primary key for the table. By default, it creates a single-column integer primary key, but you can customize the data type, size, precision, and whether it should auto-increment. If you need composite primary keys, you can call this method multiple times within the same table definition. Additionally, you can configure references to other tables, along with cascading behaviors for updates and deletes. Only available in the migrator CFC.",
    "body": [
      "primaryKey(name = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "primaryKey(allParams)": {
    "prefix": "primaryKey",
    "description": "Used inside migration table definitions to define a primary key for the table. By default, it creates a single-column integer primary key, but you can customize the data type, size, precision, and whether it should auto-increment. If you need composite primary keys, you can call this method multiple times within the same table definition. Additionally, you can configure references to other tables, along with cascading behaviors for updates and deletes. Only available in the migrator CFC.",
    "body": [
      "primaryKey(name = ${1:\"\"}, type = ${2:\"integer\"}, autoIncrement = ${3:\"false\"}, limit = ${4:\"\"}, precision = ${5:\"\"}, scale = ${6:\"\"}, references = ${7:\"\"}, onUpdate = ${8:\"\"}, onDelete = ${9:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "primaryKeys": {
    "prefix": "primaryKeys",
    "description": "Alias for <code>primaryKey()</code>.\nUse this for better readability when you're accessing multiple primary keys.",
    "body": [
      "primaryKeys()$0"
    ],
    "scope": "cfml"
  },
  "primaryKeys(allParams)": {
    "prefix": "primaryKeys",
    "description": "Alias for <code>primaryKey()</code>.\nUse this for better readability when you're accessing multiple primary keys.",
    "body": [
      "primaryKeys(position = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "processAction": {
    "prefix": "processAction",
    "description": "Process the specified action of the controller.\nThis is exposed in the API primarily for testing purposes; you would not usually call it directly unless in the test suite. The optional includeFilters argument allows you to control whether before filters, after filters, or no filters at all should run when invoking the action. By default, all filters execute unless explicitly restricted.",
    "body": [
      "processAction()$0"
    ],
    "scope": "cfml"
  },
  "processAction(allParams)": {
    "prefix": "processAction",
    "description": "Process the specified action of the controller.\nThis is exposed in the API primarily for testing purposes; you would not usually call it directly unless in the test suite. The optional includeFilters argument allows you to control whether before filters, after filters, or no filters at all should run when invoking the action. By default, all filters execute unless explicitly restricted.",
    "body": [
      "processAction(includeFilters = ${1:\"True\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "processRequest": {
    "prefix": "processRequest",
    "description": "Creates a controller and calls an action on it.\nWhich controller and action that's called is determined by the params passed in.\nReturns the result of the request either as a string or in a struct with <code>body</code>, <code>emails</code>, <code>files</code>, <code>flash</code>, <code>redirect</code>, <code>status</code>, and <code>type</code>.\nPrimarily used for testing purposes.",
    "body": [
      "processRequest(params = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "processRequest(allParams)": {
    "prefix": "processRequest",
    "description": "Creates a controller and calls an action on it.\nWhich controller and action that's called is determined by the params passed in.\nReturns the result of the request either as a string or in a struct with <code>body</code>, <code>emails</code>, <code>files</code>, <code>flash</code>, <code>redirect</code>, <code>status</code>, and <code>type</code>.\nPrimarily used for testing purposes.",
    "body": [
      "processRequest(params = ${1:\"\"}, method = ${2:\"get\"}, returnAs = ${3:\"\"}, rollback = ${4:\"\"}, includeFilters = ${5:\"True\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "properties": {
    "prefix": "properties",
    "description": "Returns a structure containing all the properties of a model object, where the keys are the property (column) names and the values are the current values for that object. This is useful when you want to inspect all the attributes of a record at once, serialize data, or debug object state. By default, properties() includes nested or associated properties (such as related objects). You can control this behavior using the returnIncluded argument to exclude them if you only want the direct properties of the object.",
    "body": [
      "properties()$0"
    ],
    "scope": "cfml"
  },
  "properties(allParams)": {
    "prefix": "properties",
    "description": "Returns a structure containing all the properties of a model object, where the keys are the property (column) names and the values are the current values for that object. This is useful when you want to inspect all the attributes of a record at once, serialize data, or debug object state. By default, properties() includes nested or associated properties (such as related objects). You can control this behavior using the returnIncluded argument to exclude them if you only want the direct properties of the object.",
    "body": [
      "properties(returnIncluded = ${1:\"True\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "property": {
    "prefix": "property",
    "description": "Lets you customize how model properties map to database columns or SQL expressions. By default, Wheels automatically maps a model’s property name to the column with the same name in the table. However, when your database uses non-standard column names, calculated values, or requires custom behavior, you can use property() to override the default mapping.",
    "body": [
      "property(name = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "property(allParams)": {
    "prefix": "property",
    "description": "Lets you customize how model properties map to database columns or SQL expressions. By default, Wheels automatically maps a model’s property name to the column with the same name in the table. However, when your database uses non-standard column names, calculated values, or requires custom behavior, you can use property() to override the default mapping.",
    "body": [
      "property(name = ${1:\"\"}, column = ${2:\"\"}, sql = ${3:\"\"}, label = ${4:\"\"}, defaultValue = ${5:\"\"}, select = ${6:\"true\"}, dataType = ${7:\"char\"}, automaticValidations = ${8:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "propertyIsBlank": {
    "prefix": "propertyIsBlank",
    "description": "Returns <code>true</code> if the specified property doesn't exist on the model or is an empty string.\nThis method is the inverse of <code>propertyIsPresent()</code>.",
    "body": [
      "propertyIsBlank(property = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "propertyIsPresent": {
    "prefix": "propertyIsPresent",
    "description": "Returns <code>true</code> if the specified property exists on the model and is not a blank string. This is the inverse of propertyIsBlank() which checks that a property is either missing or empty.",
    "body": [
      "propertyIsPresent(property = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "propertyNames": {
    "prefix": "propertyNames",
    "description": "Returns a list of all property names associated with a model. The list is ordered by the columns’ ordinal positions as they exist in the underlying database table. In addition to actual table columns, the list also includes any calculated properties defined through the property(), method, which may be derived from SQL expressions or mapped column names. This is useful when you need to dynamically work with all of a model’s attributes without hardcoding them, such as generating dynamic forms, building custom serializers, or inspecting ORM mappings.",
    "body": [
      "propertyNames()$0"
    ],
    "scope": "cfml"
  },
  "protectedProperties": {
    "prefix": "protectedProperties",
    "description": "Used to protect one or more model properties from being set or modified through mass assignment operations. Mass assignment occurs when values are assigned to a model in bulk, such as through create(), update(), or updateAll() using a struct of data. By marking certain properties as protected, you can prevent accidental or malicious changes to sensitive fields (such as id, role, or passwordHash). This method is typically called in the model’s config() function to define rules that apply across the entire model.",
    "body": [
      "protectedProperties()$0"
    ],
    "scope": "cfml"
  },
  "protectedProperties(allParams)": {
    "prefix": "protectedProperties",
    "description": "Used to protect one or more model properties from being set or modified through mass assignment operations. Mass assignment occurs when values are assigned to a model in bulk, such as through create(), update(), or updateAll() using a struct of data. By marking certain properties as protected, you can prevent accidental or malicious changes to sensitive fields (such as id, role, or passwordHash). This method is typically called in the model’s config() function to define rules that apply across the entire model.",
    "body": [
      "protectedProperties(properties = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "protectsFromForgery": {
    "prefix": "protectsFromForgery",
    "description": "Tells Wheels to protect <code>POST</code>ed requests from CSRF vulnerabilities.\nInstructs the controller to verify that <code>params.authenticityToken</code> or <code>X-CSRF-Token</code> HTTP header is provided along with the request containing a valid authenticity token.\nCall this method within a controller's <code>config</code> method, preferably the base <code>Controller.cfc</code> file, to protect the entire application.",
    "body": [
      "protectsFromForgery()$0"
    ],
    "scope": "cfml"
  },
  "protectsFromForgery(allParams)": {
    "prefix": "protectsFromForgery",
    "description": "Tells Wheels to protect <code>POST</code>ed requests from CSRF vulnerabilities.\nInstructs the controller to verify that <code>params.authenticityToken</code> or <code>X-CSRF-Token</code> HTTP header is provided along with the request containing a valid authenticity token.\nCall this method within a controller's <code>config</code> method, preferably the base <code>Controller.cfc</code> file, to protect the entire application.",
    "body": [
      "protectsFromForgery(with = ${1:\"exception\"}, only = ${2:\"\"}, except = ${3:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "provides": {
    "prefix": "provides",
    "description": "The `provides()` function defines the response formats that a controller can return. Clients can request a specific format in three ways: by using a URL parameter called `format` (e.g., `?format=json`), by appending the format as an extension to the URL (e.g., `/users/1.json`) when URL rewriting is enabled, or by specifying the desired format in the `Accept` header of the HTTP request. By defining the supported formats, you ensure that your controller can automatically render the response in the requested format, such as HTML, JSON, XML, CSV, PDF, or XLS. If no format is requested or supported, the controller defaults to HTML.",
    "body": [
      "provides()$0"
    ],
    "scope": "cfml"
  },
  "provides(allParams)": {
    "prefix": "provides",
    "description": "The `provides()` function defines the response formats that a controller can return. Clients can request a specific format in three ways: by using a URL parameter called `format` (e.g., `?format=json`), by appending the format as an extension to the URL (e.g., `/users/1.json`) when URL rewriting is enabled, or by specifying the desired format in the `Accept` header of the HTTP request. By defining the supported formats, you ensure that your controller can automatically render the response in the requested format, such as HTML, JSON, XML, CSV, PDF, or XLS. If no format is requested or supported, the controller defaults to HTML.",
    "body": [
      "provides(formats = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "put": {
    "prefix": "put",
    "description": "Create a route that matches a URL requiring an HTTP <code>PUT</code> method. We recommend using this matcher to expose actions that update database records. This method is provided as a convenience for when you really need to support the <code>PUT</code> verb. Consider using the <code>patch</code> matcher instead of this one.",
    "body": [
      "put()$0"
    ],
    "scope": "cfml"
  },
  "put(allParams)": {
    "prefix": "put",
    "description": "Create a route that matches a URL requiring an HTTP <code>PUT</code> method. We recommend using this matcher to expose actions that update database records. This method is provided as a convenience for when you really need to support the <code>PUT</code> verb. Consider using the <code>patch</code> matcher instead of this one.",
    "body": [
      "put(name = ${1:\"\"}, pattern = ${2:\"\"}, to = ${3:\"\"}, controller = ${4:\"\"}, action = ${5:\"\"}, package = ${6:\"\"}, on = ${7:\"\"}, redirect = ${8:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "radioButton": {
    "prefix": "radioButton",
    "description": "Generates an HTML radio button for a form, based on a model object’s property. It can handle simple properties as well as nested properties through associations, making it ideal for forms that work with both individual objects and collections. You can customize the radio button with additional attributes, labels, and error handling options. It automatically reflects the object’s current property value, so if the property matches the tagValue, the radio button will be marked as checked. This function helps you build dynamic forms safely and easily, with support for encoding to prevent XSS attacks, error highlighting, and custom HTML wrapping.\nNote: Pass any additional arguments like class, rel, and id, and the generated tag will also include those values as HTML attributes.",
    "body": [
      "radioButton(objectName = ${1:\"\"}, property = ${2:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "radioButton(allParams)": {
    "prefix": "radioButton",
    "description": "Generates an HTML radio button for a form, based on a model object’s property. It can handle simple properties as well as nested properties through associations, making it ideal for forms that work with both individual objects and collections. You can customize the radio button with additional attributes, labels, and error handling options. It automatically reflects the object’s current property value, so if the property matches the tagValue, the radio button will be marked as checked. This function helps you build dynamic forms safely and easily, with support for encoding to prevent XSS attacks, error highlighting, and custom HTML wrapping.\nNote: Pass any additional arguments like class, rel, and id, and the generated tag will also include those values as HTML attributes.",
    "body": [
      "radioButton(objectName = ${1:\"\"}, property = ${2:\"\"}, association = ${3:\"\"}, position = ${4:\"\"}, tagValue = ${5:\"\"}, label = ${6:\"useDefaultLabel\"}, labelPlacement = ${7:\"around\"}, prepend = ${8:\"\"}, append = ${9:\"\"}, prependToLabel = ${10:\"\"}, appendToLabel = ${11:\"\"}, errorElement = ${12:\"span\"}, errorClass = ${13:\"field-with-errors\"}, encode = ${14:\"True\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "radioButtonTag": {
    "prefix": "radioButtonTag",
    "description": "Generates a standard HTML &lt;input type=\"radio\"&gt; element based on the supplied name and value. Unlike radioButton(), this function works directly with form tags rather than binding to a model object. It is useful for simple forms or when you need fine-grained control over the HTML attributes. You can customize the radio button with labels, label placement, HTML wrapping, and encoding to prevent XSS attacks. The generated radio button will be marked as checked if the checked argument is true.",
    "body": [
      "radioButtonTag(name = ${1:\"\"}, value = ${2:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "radioButtonTag(allParams)": {
    "prefix": "radioButtonTag",
    "description": "Generates a standard HTML &lt;input type=\"radio\"&gt; element based on the supplied name and value. Unlike radioButton(), this function works directly with form tags rather than binding to a model object. It is useful for simple forms or when you need fine-grained control over the HTML attributes. You can customize the radio button with labels, label placement, HTML wrapping, and encoding to prevent XSS attacks. The generated radio button will be marked as checked if the checked argument is true.",
    "body": [
      "radioButtonTag(name = ${1:\"\"}, value = ${2:\"\"}, checked = ${3:\"\"}, label = ${4:\"\"}, labelPlacement = ${5:\"around\"}, prepend = ${6:\"\"}, append = ${7:\"\"}, prependToLabel = ${8:\"\"}, appendToLabel = ${9:\"\"}, encode = ${10:\"True\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "raised": {
    "prefix": "raised",
    "description": "Used in legacy Wheels testing to catch errors or exceptions raised by a given CFML expression. It evaluates the expression and, if an error occurs, returns the type of the error. This is especially useful when writing tests to ensure that specific operations correctly trigger exceptions under invalid or unexpected conditions. By using raised(), you can assert that your code behaves safely and predictably when encountering errors.",
    "body": [
      "raised(expression = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "redirectTo": {
    "prefix": "redirectTo",
    "description": "Used to redirect the browser to another page, action, controller, route, or back to the referring page. Internally, it uses Wheels’ URLFor() function to construct the URL and the &lt;cflocation&gt; tag (or equivalent in your CFML engine) to perform the actual redirect. You can redirect to internal routes or controllers, pass keys and query parameters, include anchors, override protocol, host, or port, and even delay the redirect until after your action code executes. This function ensures URLs are safely encoded and properly formatted for the redirect.",
    "body": [
      "redirectTo()$0"
    ],
    "scope": "cfml"
  },
  "redirectTo(allParams)": {
    "prefix": "redirectTo",
    "description": "Used to redirect the browser to another page, action, controller, route, or back to the referring page. Internally, it uses Wheels’ URLFor() function to construct the URL and the &lt;cflocation&gt; tag (or equivalent in your CFML engine) to perform the actual redirect. You can redirect to internal routes or controllers, pass keys and query parameters, include anchors, override protocol, host, or port, and even delay the redirect until after your action code executes. This function ensures URLs are safely encoded and properly formatted for the redirect.",
    "body": [
      "redirectTo(back = ${1:\"\"}, addToken = ${2:\"\"}, statusCode = ${3:\"302\"}, route = ${4:\"\"}, method = ${5:\"\"}, controller = ${6:\"\"}, action = ${7:\"\"}, key = ${8:\"\"}, params = ${9:\"\"}, anchor = ${10:\"\"}, onlyPath = ${11:\"True\"}, host = ${12:\"\"}, protocol = ${13:\"\"}, port = ${14:\"\"}, url = ${15:\"\"}, delay = ${16:\"\"}, encode = ${17:\"True\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "redoMigration": {
    "prefix": "redoMigration",
    "description": "Allows you to rerun a specific database migration version. This can be useful for testing migrations, correcting issues in a migration, or resetting a schema change during development. While it can be called directly from your application code, it is generally recommended to use this function via the CommandBox CLI or the Wheels GUI migration interface, as these provide safer execution and logging.",
    "body": [
      "redoMigration()$0"
    ],
    "scope": "cfml"
  },
  "redoMigration(allParams)": {
    "prefix": "redoMigration",
    "description": "Allows you to rerun a specific database migration version. This can be useful for testing migrations, correcting issues in a migration, or resetting a schema change during development. While it can be called directly from your application code, it is generally recommended to use this function via the CommandBox CLI or the Wheels GUI migration interface, as these provide safer execution and logging.",
    "body": [
      "redoMigration(version = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "references": {
    "prefix": "references",
    "description": "Used when defining a table schema to add reference columns that act as foreign keys, linking the table to other tables in the database. It automatically creates integer columns for the references and sets up foreign key constraints, helping maintain referential integrity. You can customize the behavior of these reference columns, including whether they allow nulls, default values, or support polymorphic associations. You can also define actions for ON UPDATE and ON DELETE events.",
    "body": [
      "references(referenceNames = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "references(allParams)": {
    "prefix": "references",
    "description": "Used when defining a table schema to add reference columns that act as foreign keys, linking the table to other tables in the database. It automatically creates integer columns for the references and sets up foreign key constraints, helping maintain referential integrity. You can customize the behavior of these reference columns, including whether they allow nulls, default values, or support polymorphic associations. You can also define actions for ON UPDATE and ON DELETE events.",
    "body": [
      "references(referenceNames = ${1:\"\"}, default = ${2:\"\"}, allowNull = ${3:\"false\"}, polymorphic = ${4:\"false\"}, foreignKey = ${5:\"true\"}, onUpdate = ${6:\"\"}, onDelete = ${7:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "reload": {
    "prefix": "reload",
    "description": "Refreshes the property values of a model object from the database. This is useful when an object’s values might have changed in the database due to other operations or external processes. By calling reload(), you ensure that your object reflects the current state of the corresponding database record.",
    "body": [
      "reload()$0"
    ],
    "scope": "cfml"
  },
  "removeColumn": {
    "prefix": "removeColumn",
    "description": "Used to delete a column from a database table within a migration CFC. This is useful when you need to remove obsolete or incorrectly added columns during schema evolution. Optionally, you can also remove a reference column by specifying its referenceName. Only available in a migration CFC.",
    "body": [
      "removeColumn(table = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "removeColumn(allParams)": {
    "prefix": "removeColumn",
    "description": "Used to delete a column from a database table within a migration CFC. This is useful when you need to remove obsolete or incorrectly added columns during schema evolution. Optionally, you can also remove a reference column by specifying its referenceName. Only available in a migration CFC.",
    "body": [
      "removeColumn(table = ${1:\"\"}, columnName = ${2:\"\"}, referenceName = ${3:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "removeIndex": {
    "prefix": "removeIndex",
    "description": "Used to delete an index from a database table within a migration CFC. Indexes are typically added to improve query performance, but there are scenarios where an index becomes unnecessary or needs to be replaced. Using removeIndex() allows you to safely remove an index while maintaining database integrity. Only available in a migration CFC.",
    "body": [
      "removeIndex(table = ${1:\"\"}, indexName = ${2:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "removeRecord": {
    "prefix": "removeRecord",
    "description": "Used to delete specific records from a database table within a migration CFC. This is useful when you need to clean up obsolete data, remove test data, or correct records as part of a schema migration. You can optionally provide a where clause to target specific rows. If no where clause is provided, the behavior depends on the database; usually, no records are removed unless explicitly specified. Only available in a migration CFC.",
    "body": [
      "removeRecord(table = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "removeRecord(allParams)": {
    "prefix": "removeRecord",
    "description": "Used to delete specific records from a database table within a migration CFC. This is useful when you need to clean up obsolete data, remove test data, or correct records as part of a schema migration. You can optionally provide a where clause to target specific rows. If no where clause is provided, the behavior depends on the database; usually, no records are removed unless explicitly specified. Only available in a migration CFC.",
    "body": [
      "removeRecord(table = ${1:\"\"}, where = ${2:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "renameColumn": {
    "prefix": "renameColumn",
    "description": "Used to change the name of an existing column in a database table within a migration CFC. This is useful when you need to standardize column names, correct naming mistakes, or improve clarity in your database schema. Renaming a column preserves the existing data and column type while updating the schema. Only available in a migration CFC.",
    "body": [
      "renameColumn(table = ${1:\"\"}, columnName = ${2:\"\"}, newColumnName = ${3:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "renameTable": {
    "prefix": "renameTable",
    "description": "Used to change the name of an existing database table within a migration CFC. This is helpful when you want to standardize table names, correct naming mistakes, or improve clarity in your database schema. This operation preserves all the existing data, indexes, and constraints in the table while updating its name. Only available in a migration CFC.",
    "body": [
      "renameTable(oldName = ${1:\"\"}, newName = ${2:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "renderNothing": {
    "prefix": "renderNothing",
    "description": "Instructs the controller to render an empty response when an action completes. Unlike using cfabort, which stops request processing immediately, renderNothing() ensures that any after filters associated with the action still execute. You can optionally provide an HTTP status code to indicate the type of response being returned. This is useful for APIs or endpoints that need to signal a specific status without returning a body.",
    "body": [
      "renderNothing()$0"
    ],
    "scope": "cfml"
  },
  "renderNothing(allParams)": {
    "prefix": "renderNothing",
    "description": "Instructs the controller to render an empty response when an action completes. Unlike using cfabort, which stops request processing immediately, renderNothing() ensures that any after filters associated with the action still execute. You can optionally provide an HTTP status code to indicate the type of response being returned. This is useful for APIs or endpoints that need to signal a specific status without returning a body.",
    "body": [
      "renderNothing(status = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "renderPartial": {
    "prefix": "renderPartial",
    "description": "Instructs the controller to render a partial view when an action completes. Partials are reusable view fragments, typically prefixed with an underscore (e.g., _comment.cfm). This function allows you to render these fragments either directly to the client or capture them as a string for further processing. You can control caching, layouts, HTTP status codes, and data-loading behavior, making it flexible for both full-page updates and AJAX responses.",
    "body": [
      "renderPartial(partial = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "renderPartial(allParams)": {
    "prefix": "renderPartial",
    "description": "Instructs the controller to render a partial view when an action completes. Partials are reusable view fragments, typically prefixed with an underscore (e.g., _comment.cfm). This function allows you to render these fragments either directly to the client or capture them as a string for further processing. You can control caching, layouts, HTTP status codes, and data-loading behavior, making it flexible for both full-page updates and AJAX responses.",
    "body": [
      "renderPartial(partial = ${1:\"\"}, cache = ${2:\"\"}, layout = ${3:\"\"}, returnAs = ${4:\"\"}, dataFunction = ${5:\"True\"}, status = ${6:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "renderText": {
    "prefix": "renderText",
    "description": "Instructs the controller to output plain text as the response when an action completes. Unlike rendering a view or partial, this sends the specified text directly to the client. This is especially useful for APIs, AJAX responses, or simple status messages. You can also provide an HTTP status code to control the response status.",
    "body": [
      "renderText()$0"
    ],
    "scope": "cfml"
  },
  "renderText(allParams)": {
    "prefix": "renderText",
    "description": "Instructs the controller to output plain text as the response when an action completes. Unlike rendering a view or partial, this sends the specified text directly to the client. This is especially useful for APIs, AJAX responses, or simple status messages. You can also provide an HTTP status code to control the response status.",
    "body": [
      "renderText(text = ${1:\"\"}, status = ${2:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "renderView": {
    "prefix": "renderView",
    "description": "Instructs the controller which view template and layout to render when it's finished processing the action.\nNote that when passing values for controller and / or action, this function does not execute the actual action but rather just loads the corresponding view template.",
    "body": [
      "renderView()$0"
    ],
    "scope": "cfml"
  },
  "renderView(allParams)": {
    "prefix": "renderView",
    "description": "Instructs the controller which view template and layout to render when it's finished processing the action.\nNote that when passing values for controller and / or action, this function does not execute the actual action but rather just loads the corresponding view template.",
    "body": [
      "renderView(controller = ${1:\"\"}, action = ${2:\"\"}, template = ${3:\"\"}, layout = ${4:\"\"}, cache = ${5:\"\"}, returnAs = ${6:\"\"}, hideDebugInformation = ${7:\"\"}, status = ${8:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "renderWith": {
    "prefix": "renderWith",
    "description": "Instructs the controller to render the given data in the format requested by the client. If the requested format is json or xml, Wheels automatically converts the data into the appropriate format. For other formats—or to override automatic formatting—you can create a view template matching the requested format, such as nameofaction.json.cfm, nameofaction.xml.cfm, or nameofaction.pdf.cfm. This function is especially useful in APIs, AJAX endpoints, or situations where you need to respond dynamically in multiple formats based on client preferences. You can also control caching, layout, HTTP status codes, and whether to return the result as a string for further processing.",
    "body": [
      "renderWith(data = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "renderWith(allParams)": {
    "prefix": "renderWith",
    "description": "Instructs the controller to render the given data in the format requested by the client. If the requested format is json or xml, Wheels automatically converts the data into the appropriate format. For other formats—or to override automatic formatting—you can create a view template matching the requested format, such as nameofaction.json.cfm, nameofaction.xml.cfm, or nameofaction.pdf.cfm. This function is especially useful in APIs, AJAX endpoints, or situations where you need to respond dynamically in multiple formats based on client preferences. You can also control caching, layout, HTTP status codes, and whether to return the result as a string for further processing.",
    "body": [
      "renderWith(data = ${1:\"\"}, controller = ${2:\"\"}, action = ${3:\"\"}, template = ${4:\"\"}, layout = ${5:\"\"}, cache = ${6:\"\"}, returnAs = ${7:\"\"}, hideDebugInformation = ${8:\"\"}, status = ${9:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "resetCycle": {
    "prefix": "resetCycle",
    "description": "Rsets a named cycle, allowing it to start from the first value the next time it is called. In Wheels, cycle() is often used to alternate values in a repeated pattern, such as CSS classes for table rows, positions, or emphasis levels. By calling resetCycle(), you ensure that the cycle begins again from its initial value, which is useful when looping through nested structures or when a new grouping starts.",
    "body": [
      "resetCycle()$0"
    ],
    "scope": "cfml"
  },
  "resetCycle(allParams)": {
    "prefix": "resetCycle",
    "description": "Rsets a named cycle, allowing it to start from the first value the next time it is called. In Wheels, cycle() is often used to alternate values in a repeated pattern, such as CSS classes for table rows, positions, or emphasis levels. By calling resetCycle(), you ensure that the cycle begins again from its initial value, which is useful when looping through nested structures or when a new grouping starts.",
    "body": [
      "resetCycle(name = ${1:\"default\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "resource": {
    "prefix": "resource",
    "description": "Create a group of routes that exposes actions for manipulating a singular resource. A singular resource exposes URL patterns for the entire CRUD lifecycle of a single entity (<code>show</code>, <code>new</code>, <code>create</code>, <code>edit</code>, <code>update</code>, and <code>delete</code>) without exposing a primary key in the URL. Usually this type of resource represents a singleton entity tied to the session, application, or another resource (perhaps nested within another resource). If you need to generate routes for manipulating a collection of resources with a primary key in the URL, see the <code>resources</code> mapper method.",
    "body": [
      "resource(name = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "resource(allParams)": {
    "prefix": "resource",
    "description": "Create a group of routes that exposes actions for manipulating a singular resource. A singular resource exposes URL patterns for the entire CRUD lifecycle of a single entity (<code>show</code>, <code>new</code>, <code>create</code>, <code>edit</code>, <code>update</code>, and <code>delete</code>) without exposing a primary key in the URL. Usually this type of resource represents a singleton entity tied to the session, application, or another resource (perhaps nested within another resource). If you need to generate routes for manipulating a collection of resources with a primary key in the URL, see the <code>resources</code> mapper method.",
    "body": [
      "resource(name = ${1:\"\"}, nested = ${2:\"\"}, path = ${3:\"\"}, controller = ${4:\"\"}, singular = ${5:\"\"}, plural = ${6:\"\"}, only = ${7:\"\"}, except = ${8:\"\"}, shallow = ${9:\"\"}, shallowPath = ${10:\"\"}, shallowName = ${11:\"\"}, constraints = ${12:\"\"}, $call = ${13:\"resource\"}, $plural = ${14:\"\"}, mapFormat = ${15:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "resources": {
    "prefix": "resources",
    "description": "Create a group of routes that exposes actions for manipulating a collection of resources. A plural resource exposes URL patterns for the entire CRUD lifecycle (<code>index</code>, <code>show</code>, <code>new</code>, <code>create</code>, <code>edit</code>, <code>update</code>, <code>delete</code>), exposing a primary key in the URL for showing, editing, updating, and deleting records. If you need to generate routes for manipulating a singular resource without a primary key, see the <code>resource</code> mapper method.",
    "body": [
      "resources(name = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "resources(allParams)": {
    "prefix": "resources",
    "description": "Create a group of routes that exposes actions for manipulating a collection of resources. A plural resource exposes URL patterns for the entire CRUD lifecycle (<code>index</code>, <code>show</code>, <code>new</code>, <code>create</code>, <code>edit</code>, <code>update</code>, <code>delete</code>), exposing a primary key in the URL for showing, editing, updating, and deleting records. If you need to generate routes for manipulating a singular resource without a primary key, see the <code>resource</code> mapper method.",
    "body": [
      "resources(name = ${1:\"\"}, nested = ${2:\"\"}, path = ${3:\"\"}, controller = ${4:\"\"}, singular = ${5:\"\"}, plural = ${6:\"\"}, only = ${7:\"\"}, except = ${8:\"\"}, shallow = ${9:\"\"}, shallowPath = ${10:\"\"}, shallowName = ${11:\"\"}, constraints = ${12:\"\"}, mapFormat = ${13:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "response": {
    "prefix": "response",
    "description": "Returns the content that Wheels is preparing to send back to the client for the current request. This can include the output generated by renderView(), renderPartial(), renderText(), or any other rendering function that has been called during the request lifecycle. Essentially, response() lets you inspect or manipulate the final output before it is sent to the client, which can be particularly useful in testing, debugging, or middleware-style functions.",
    "body": [
      "response()$0"
    ],
    "scope": "cfml"
  },
  "root": {
    "prefix": "root",
    "description": "Defines a route that matches the root of the current context. This could be the root of the entire application (like the home page) or the root of a namespaced section of your routes. It is commonly used to map a controller action to the main entry point of your application or a subsection of it. You can specify the controller and action either using the to argument (controller##action) or by passing controller and action separately. Optionally, mapFormat can be set to true to allow a format suffix like .json or .xml in the URL.",
    "body": [
      "root()$0"
    ],
    "scope": "cfml"
  },
  "root(allParams)": {
    "prefix": "root",
    "description": "Defines a route that matches the root of the current context. This could be the root of the entire application (like the home page) or the root of a namespaced section of your routes. It is commonly used to map a controller action to the main entry point of your application or a subsection of it. You can specify the controller and action either using the to argument (controller##action) or by passing controller and action separately. Optionally, mapFormat can be set to true to allow a format suffix like .json or .xml in the URL.",
    "body": [
      "root(to = ${1:\"\"}, mapFormat = ${2:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "save": {
    "prefix": "save",
    "description": "Saves the current model object to the database, with Wheels automatically determining whether to perform an INSERT for new objects or an UPDATE for existing ones. It returns true if the object was successfully saved, and false if the object failed validation or could not be saved. By default, save() also respects callbacks, validations, and parameterization, though these behaviors can be customized through optional arguments.",
    "body": [
      "save()$0"
    ],
    "scope": "cfml"
  },
  "save(allParams)": {
    "prefix": "save",
    "description": "Saves the current model object to the database, with Wheels automatically determining whether to perform an INSERT for new objects or an UPDATE for existing ones. It returns true if the object was successfully saved, and false if the object failed validation or could not be saved. By default, save() also respects callbacks, validations, and parameterization, though these behaviors can be customized through optional arguments.",
    "body": [
      "save(parameterize = ${1:\"True\"}, reload = ${2:\"\"}, validate = ${3:\"True\"}, transaction = ${4:\"\"}, callbacks = ${5:\"True\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "scope": {
    "prefix": "scope",
    "description": "The scope() function in Wheels is used to define a block of routes that share common parameters such as controller, package, path, or naming prefixes. All routes defined inside a scope() block automatically inherit these parameters unless explicitly overridden, making it easier to manage related routes. This is particularly useful for grouping routes under the same controller or package, adding a common URL prefix to multiple routes, applying shallow routing to nested resources, and reducing repetition while improving the maintainability of route definitions.",
    "body": [
      "scope()$0"
    ],
    "scope": "cfml"
  },
  "scope(allParams)": {
    "prefix": "scope",
    "description": "The scope() function in Wheels is used to define a block of routes that share common parameters such as controller, package, path, or naming prefixes. All routes defined inside a scope() block automatically inherit these parameters unless explicitly overridden, making it easier to manage related routes. This is particularly useful for grouping routes under the same controller or package, adding a common URL prefix to multiple routes, applying shallow routing to nested resources, and reducing repetition while improving the maintainability of route definitions.",
    "body": [
      "scope(name = ${1:\"\"}, path = ${2:\"\"}, package = ${3:\"\"}, controller = ${4:\"\"}, shallow = ${5:\"\"}, shallowPath = ${6:\"\"}, shallowName = ${7:\"\"}, constraints = ${8:\"\"}, $call = ${9:\"scope\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "secondSelectTag": {
    "prefix": "secondSelectTag",
    "description": "Generates an HTML &lt;select&gt; form control populated with seconds (0–59) for a minute. You can bind it to a form parameter or manually set a selected value, control the step interval, include a blank option, and customize labels and HTML attributes. This is especially useful for time selection forms, like setting the seconds for a scheduled task or timestamp input.",
    "body": [
      "secondSelectTag(name = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "secondSelectTag(allParams)": {
    "prefix": "secondSelectTag",
    "description": "Generates an HTML &lt;select&gt; form control populated with seconds (0–59) for a minute. You can bind it to a form parameter or manually set a selected value, control the step interval, include a blank option, and customize labels and HTML attributes. This is especially useful for time selection forms, like setting the seconds for a scheduled task or timestamp input.",
    "body": [
      "secondSelectTag(name = ${1:\"\"}, selected = ${2:\"\"}, secondStep = ${3:\"1\"}, includeBlank = ${4:\"\"}, label = ${5:\"\"}, labelPlacement = ${6:\"around\"}, prepend = ${7:\"\"}, append = ${8:\"\"}, prependToLabel = ${9:\"\"}, appendToLabel = ${10:\"\"}, encode = ${11:\"True\"}, $now = ${12:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "select": {
    "prefix": "select",
    "description": "Builds and returns an HTML &lt;select&gt; element bound to a model object property. It automatically handles nested associations, labels, options, and error highlighting. You can provide a list of options as a query, array of objects, or simple array, and customize labels, HTML attributes, and encoding. It is especially useful for forms where a user must select a value from a predefined list that is related to a database model.\nNote: Pass any additional arguments like class, rel, and id, and the generated tag will also include those values as HTML attributes.",
    "body": [
      "select(objectName = ${1:\"\"}, property = ${2:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "select(allParams)": {
    "prefix": "select",
    "description": "Builds and returns an HTML &lt;select&gt; element bound to a model object property. It automatically handles nested associations, labels, options, and error highlighting. You can provide a list of options as a query, array of objects, or simple array, and customize labels, HTML attributes, and encoding. It is especially useful for forms where a user must select a value from a predefined list that is related to a database model.\nNote: Pass any additional arguments like class, rel, and id, and the generated tag will also include those values as HTML attributes.",
    "body": [
      "select(objectName = ${1:\"\"}, property = ${2:\"\"}, association = ${3:\"\"}, position = ${4:\"\"}, options = ${5:\"\"}, includeBlank = ${6:\"\"}, valueField = ${7:\"\"}, textField = ${8:\"\"}, label = ${9:\"useDefaultLabel\"}, labelPlacement = ${10:\"around\"}, prepend = ${11:\"\"}, append = ${12:\"\"}, prependToLabel = ${13:\"\"}, appendToLabel = ${14:\"\"}, errorElement = ${15:\"span\"}, errorClass = ${16:\"field-with-errors\"}, encode = ${17:\"True\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "selectTag": {
    "prefix": "selectTag",
    "description": "Builds an HTML &lt;select&gt; element using a name and a set of options. Unlike select(), it does not require a model object and is not bound to a property. It is useful for standalone select controls or when you want full manual control over the field.\nNote: Pass any additional arguments like <code>class</code>, <code>rel</code>, and <code>id</code>, and the generated tag will also include those values as HTML attributes.",
    "body": [
      "selectTag(name = ${1:\"\"}, options = ${2:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "selectTag(allParams)": {
    "prefix": "selectTag",
    "description": "Builds an HTML &lt;select&gt; element using a name and a set of options. Unlike select(), it does not require a model object and is not bound to a property. It is useful for standalone select controls or when you want full manual control over the field.\nNote: Pass any additional arguments like <code>class</code>, <code>rel</code>, and <code>id</code>, and the generated tag will also include those values as HTML attributes.",
    "body": [
      "selectTag(name = ${1:\"\"}, options = ${2:\"\"}, selected = ${3:\"\"}, includeBlank = ${4:\"\"}, multiple = ${5:\"\"}, valueField = ${6:\"\"}, textField = ${7:\"\"}, label = ${8:\"\"}, labelPlacement = ${9:\"around\"}, prepend = ${10:\"\"}, append = ${11:\"\"}, prependToLabel = ${12:\"\"}, appendToLabel = ${13:\"\"}, encode = ${14:\"True\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "sendEmail": {
    "prefix": "sendEmail",
    "description": "Sends an email using a template and an optional layout to wrap it in.\nBesides the Wheels-specific arguments documented here, you can also pass in any argument that is accepted by the <code>cfmail</code> tag as well as your own arguments to be used by the view.",
    "body": [
      "sendEmail()$0"
    ],
    "scope": "cfml"
  },
  "sendEmail(allParams)": {
    "prefix": "sendEmail",
    "description": "Sends an email using a template and an optional layout to wrap it in.\nBesides the Wheels-specific arguments documented here, you can also pass in any argument that is accepted by the <code>cfmail</code> tag as well as your own arguments to be used by the view.",
    "body": [
      "sendEmail(template = ${1:\"\"}, from = ${2:\"\"}, to = ${3:\"\"}, subject = ${4:\"\"}, layout = ${5:\"\"}, file = ${6:\"\"}, detectMultipart = ${7:\"True\"}, deliver = ${8:\"True\"}, writeToFile = ${9:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "sendFile": {
    "prefix": "sendFile",
    "description": "Sends a file to the client. By default, it serves files from the <code>public/files</code> folder in your project or a path relative to it. You can control how the file is presented to the user (download dialog vs inline display), set the content type, rename it for the client, or even delete it from the server after delivery.",
    "body": [
      "sendFile(file = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "sendFile(allParams)": {
    "prefix": "sendFile",
    "description": "Sends a file to the client. By default, it serves files from the <code>public/files</code> folder in your project or a path relative to it. You can control how the file is presented to the user (download dialog vs inline display), set the content type, rename it for the client, or even delete it from the server after delivery.",
    "body": [
      "sendFile(file = ${1:\"\"}, name = ${2:\"\"}, type = ${3:\"\"}, disposition = ${4:\"attachment\"}, directory = ${5:\"\"}, deleteFile = ${6:\"\"}, deliver = ${7:\"True\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "set": {
    "prefix": "set",
    "description": "Used to configure global settings or set default argument values for Wheels functions. It can be applied to core functions, helpers, and even migrations. This allows you to define a standard behavior across your application without repeating arguments every time a function is called.",
    "body": [
      "set()$0"
    ],
    "scope": "cfml"
  },
  "setFilterChain": {
    "prefix": "setFilterChain",
    "description": "Provides a low-level way to define the complete filter chain for a controller. This lets you explicitly specify the sequence of filters, their scope, and the actions they apply to, all in a single configuration. Filters are functions that run before, after, or around actions to handle tasks such as authentication, logging, or IP restrictions.",
    "body": [
      "setFilterChain(chain = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "setFlashStorage": {
    "prefix": "setFlashStorage",
    "description": "Dynamically sets the storage mechanism for flash messages during the current request lifecycle. Flash messages are temporary messages (e.g., success or error notifications) that persist across requests.",
    "body": [
      "setFlashStorage()$0"
    ],
    "scope": "cfml"
  },
  "setFlashStorage(allParams)": {
    "prefix": "setFlashStorage",
    "description": "Dynamically sets the storage mechanism for flash messages during the current request lifecycle. Flash messages are temporary messages (e.g., success or error notifications) that persist across requests.",
    "body": [
      "setFlashStorage(storage = ${1:session}, setGlobally = ${2:false})",
      "$0"
    ],
    "scope": "cfml"
  },
  "setPagination": {
    "prefix": "setPagination",
    "description": "Aallows you to define a pagination handle for a custom query so that you can easily generate paginated links and manage page offsets in your views. It’s useful when you want manual or database-driven pagination instead of relying on built-in model queries. This works in combination with the <code>pagination()</code> function to retrieve pagination metadata (like startRow, endRow, maxRows) and <code>paginationLinks()</code> to render links in your view.",
    "body": [
      "setPagination(totalRecords = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "setPagination(allParams)": {
    "prefix": "setPagination",
    "description": "Aallows you to define a pagination handle for a custom query so that you can easily generate paginated links and manage page offsets in your views. It’s useful when you want manual or database-driven pagination instead of relying on built-in model queries. This works in combination with the <code>pagination()</code> function to retrieve pagination metadata (like startRow, endRow, maxRows) and <code>paginationLinks()</code> to render links in your view.",
    "body": [
      "setPagination(totalRecords = ${1:\"\"}, currentPage = ${2:\"1\"}, perPage = ${3:\"25\"}, handle = ${4:\"query\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "setPrimaryKey": {
    "prefix": "setPrimaryKey",
    "description": "The setPrimaryKey() function allows you to define which property (or properties) of a model represent the primary key in the database. This is crucial for Wheels to correctly handle CRUD operations, updates, and record lookups. For single-column primary keys, pass the property name as a string. For composite primary keys (multiple columns together form the key), pass a comma-separated list of property names. Alias: <code>setPrimaryKeys()</code>",
    "body": [
      "setPrimaryKey(property = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "setPrimaryKeys": {
    "prefix": "setPrimaryKeys",
    "description": "Alias for <code>setPrimaryKey()</code>.\nUse this for better readability when you're setting multiple properties as the primary key.",
    "body": [
      "setPrimaryKeys(property = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "setProperties": {
    "prefix": "setProperties",
    "description": "Allows you to set multiple properties of a model object at once. It is useful when you want to update a model with a structure (struct) of key/value pairs instead of assigning each property individually. The keys of the struct should match the property names of the model. You can also pass named arguments directly instead of a struct.",
    "body": [
      "setProperties()$0"
    ],
    "scope": "cfml"
  },
  "setProperties(allParams)": {
    "prefix": "setProperties",
    "description": "Allows you to set multiple properties of a model object at once. It is useful when you want to update a model with a structure (struct) of key/value pairs instead of assigning each property individually. The keys of the struct should match the property names of the model. You can also pass named arguments directly instead of a struct.",
    "body": [
      "setProperties(properties = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "setResponse": {
    "prefix": "setResponse",
    "description": "Allows you to manually set the content that Wheels will send back to the client for a given request. Unlike <code>renderView()</code> or <code>renderText()</code>, which automatically generate output from templates or data, <code>setResponse()</code> gives you full control over the response content.",
    "body": [
      "setResponse(content = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "setTableNamePrefix": {
    "prefix": "setTableNamePrefix",
    "description": "Allows you to add a prefix to the table name used by a model when performing SQL queries. This is useful if your database uses a consistent naming convention, such as <code>tblUsers</code> instead of <code>Users</code>. By default, Wheels infers the table name from the model name (e.g., User -> users). Using a prefix ensures that all queries automatically reference the correctly prefixed table.",
    "body": [
      "setTableNamePrefix(prefix = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "setup": {
    "prefix": "setup",
    "description": "Callback used in Wheels legacy testing framework. It runs before every individual test case within a test suite. This allows you to prepare the test environment, initialize objects, or reset state before each test executes.",
    "body": [
      "setup()$0"
    ],
    "scope": "cfml"
  },
  "setVerificationChain": {
    "prefix": "setVerificationChain",
    "description": "Allows you to define the entire verification chain for a controller in a low-level, structured way. Verification chains are used to validate requests, ensuring they meet specific requirements (like HTTP method, parameters, or types) before the controller action executes. Instead of defining individual <code>verifies()</code> calls in each action, you can use <code>setVerificationChain()</code> to set all verifications at once.",
    "body": [
      "setVerificationChain(chain = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "simpleFormat": {
    "prefix": "simpleFormat",
    "description": "Takes plain text and converts newline and carriage return characters into HTML <code>&lt;br&gt;</code> and <code>&lt;p&gt;</code> tags for display in a browser. This is particularly useful for rendering user-submitted text (like blog posts, comments, or descriptions) in a way that respects the author’s formatting. By default, the text is wrapped in a <code>&lt;p&gt;</code> element and URL parameters are encoded for safety.",
    "body": [
      "simpleFormat(text = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "simpleFormat(allParams)": {
    "prefix": "simpleFormat",
    "description": "Takes plain text and converts newline and carriage return characters into HTML <code>&lt;br&gt;</code> and <code>&lt;p&gt;</code> tags for display in a browser. This is particularly useful for rendering user-submitted text (like blog posts, comments, or descriptions) in a way that respects the author’s formatting. By default, the text is wrapped in a <code>&lt;p&gt;</code> element and URL parameters are encoded for safety.",
    "body": [
      "simpleFormat(text = ${1:\"\"}, wrap = ${2:\"True\"}, encode = ${3:\"True\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "singularize": {
    "prefix": "singularize",
    "description": "Converts a plural word into its singular form. It uses Wheels’ built-in inflection rules, handling common English pluralization cases as well as irregular words. This is useful when dynamically generating model names, table names, or working with resource naming conventions.",
    "body": [
      "singularize(word = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "startFormTag": {
    "prefix": "startFormTag",
    "description": "Builds and returns an opening &lt;form&gt; tag. The form’s action URL is automatically generated following the same rules as <code>urlFor()</code>. You can pass standard Wheels routing arguments (controller, action, route, key, params) as well as custom HTML attributes (id, class, rel, etc.). Use this in combination with <code>endFormTag()</code> to wrap your form controls.",
    "body": [
      "startFormTag()$0"
    ],
    "scope": "cfml"
  },
  "startFormTag(allParams)": {
    "prefix": "startFormTag",
    "description": "Builds and returns an opening &lt;form&gt; tag. The form’s action URL is automatically generated following the same rules as <code>urlFor()</code>. You can pass standard Wheels routing arguments (controller, action, route, key, params) as well as custom HTML attributes (id, class, rel, etc.). Use this in combination with <code>endFormTag()</code> to wrap your form controls.",
    "body": [
      "startFormTag(method = ${1:\"post\"}, multipart = ${2:\"\"}, route = ${3:\"\"}, controller = ${4:\"\"}, action = ${5:\"\"}, key = ${6:\"\"}, params = ${7:\"\"}, anchor = ${8:\"\"}, onlyPath = ${9:\"True\"}, host = ${10:\"\"}, protocol = ${11:\"\"}, port = ${12:\"\"}, prepend = ${13:\"\"}, append = ${14:\"\"}, encode = ${15:\"True\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "string": {
    "prefix": "string",
    "description": "Used to add one or more string (VARCHAR) columns to a database table. It supports specifying default values, nullability, and a maximum length (limit). Only available in a migrator CFC.",
    "body": [
      "string()$0"
    ],
    "scope": "cfml"
  },
  "string(allParams)": {
    "prefix": "string",
    "description": "Used to add one or more string (VARCHAR) columns to a database table. It supports specifying default values, nullability, and a maximum length (limit). Only available in a migrator CFC.",
    "body": [
      "string(columnNames = ${1:\"\"}, limit = ${2:\"\"}, default = ${3:\"\"}, allowNull = ${4:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "stripLinks": {
    "prefix": "stripLinks",
    "description": "Removes all &lt;a&gt; tags (hyperlinks) from an HTML string while preserving the inner text. This is useful when you want to display content without clickable links but still retain the text inside them.",
    "body": [
      "stripLinks(html = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "stripLinks(allParams)": {
    "prefix": "stripLinks",
    "description": "Removes all &lt;a&gt; tags (hyperlinks) from an HTML string while preserving the inner text. This is useful when you want to display content without clickable links but still retain the text inside them.",
    "body": [
      "stripLinks(html = ${1:\"\"}, encode = ${2:\"True\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "stripTags": {
    "prefix": "stripTags",
    "description": "Removes all HTML tags from a string, leaving only the raw text content. Use this when you need to sanitize HTML by completely removing formatting and markup.",
    "body": [
      "stripTags(html = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "stripTags(allParams)": {
    "prefix": "stripTags",
    "description": "Removes all HTML tags from a string, leaving only the raw text content. Use this when you need to sanitize HTML by completely removing formatting and markup.",
    "body": [
      "stripTags(html = ${1:\"\"}, encode = ${2:\"True\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "styleSheetLinkTag": {
    "prefix": "styleSheetLinkTag",
    "description": "Generates one or more &lt;link&gt; tags for including CSS stylesheets in your application. By default, it looks in the <code>publicstylesheets</code> folder of your app but can also handle external URLs or place stylesheets directly in the &lt;head&gt; section when needed.",
    "body": [
      "styleSheetLinkTag()$0"
    ],
    "scope": "cfml"
  },
  "styleSheetLinkTag(allParams)": {
    "prefix": "styleSheetLinkTag",
    "description": "Generates one or more &lt;link&gt; tags for including CSS stylesheets in your application. By default, it looks in the <code>publicstylesheets</code> folder of your app but can also handle external URLs or place stylesheets directly in the &lt;head&gt; section when needed.",
    "body": [
      "styleSheetLinkTag(sources = ${1:\"\"}, type = ${2:\"text/css\"}, media = ${3:\"all\"}, rel = ${4:\"\"}, head = ${5:\"\"}, delim = ${6:\",\"}, encode = ${7:\"True\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "submitTag": {
    "prefix": "submitTag",
    "description": "Builds and returns a string containing a submit button form control.\nNote: Pass any additional arguments like class, rel, and id, and the generated tag will also include those values as HTML attributes.",
    "body": [
      "submitTag()$0"
    ],
    "scope": "cfml"
  },
  "submitTag(allParams)": {
    "prefix": "submitTag",
    "description": "Builds and returns a string containing a submit button form control.\nNote: Pass any additional arguments like class, rel, and id, and the generated tag will also include those values as HTML attributes.",
    "body": [
      "submitTag(value = ${1:\"Save changes\"}, image = ${2:\"\"}, prepend = ${3:\"\"}, append = ${4:\"\"}, encode = ${5:\"True\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "sum": {
    "prefix": "sum",
    "description": "Calculates the total of all values for a given property (column) using SQL’s <code>SUM()</code> function. It’s typically used to aggregate numeric values across a set of records (e.g., summing salaries, prices, or quantities). You can add filtering with where, group results with group, or join associations using include. If no records are found, use the ifNull argument to return a safe default (commonly 0 for numeric sums).",
    "body": [
      "sum(property = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "sum(allParams)": {
    "prefix": "sum",
    "description": "Calculates the total of all values for a given property (column) using SQL’s <code>SUM()</code> function. It’s typically used to aggregate numeric values across a set of records (e.g., summing salaries, prices, or quantities). You can add filtering with where, group results with group, or join associations using include. If no records are found, use the ifNull argument to return a safe default (commonly 0 for numeric sums).",
    "body": [
      "sum(property = ${1:\"\"}, where = ${2:\"\"}, include = ${3:\"\"}, distinct = ${4:\"\"}, parameterize = ${5:\"True\"}, ifNull = ${6:\"\"}, includeSoftDeletes = ${7:\"false\"}, group = ${8:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "table": {
    "prefix": "table",
    "description": "Used to tell Wheels which database table a model should connect to. Normally, Wheels automatically maps a model name to a plural table name (for example, a model named <code>User</code> maps to the <code>users</code> table). However, when your database uses custom naming conventions that do not match the Wheels defaults, you can override the mapping by explicitly specifying the table name with <code>table()</code>. If you want a model to not be tied to any database table at all, you can set <code>table(false)</code>. This is useful for models that are used purely for logic, service layers, or scenarios where the model acts as a data wrapper without persistence.",
    "body": [
      "table(name = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "tableName": {
    "prefix": "tableName",
    "description": "Returns the name of the database table that a model is mapped to. Wheels automatically determines the table name based on its naming convention, where a singular model name maps to a plural table name (for example, a model named User maps to the users table). If the table has been explicitly overridden using the <code>table()</code> function in the model’s <code>config()</code>, then <code>tableName()</code> will return the custom mapping instead. This function is useful when you want to programmatically check or log the database table a model is connected to, especially in projects with mixed or legacy naming conventions.",
    "body": [
      "tableName()$0"
    ],
    "scope": "cfml"
  },
  "teardown": {
    "prefix": "teardown",
    "description": "Callback that executes after every test case when using Wheels’ legacy testing framework. It is typically used to clean up any data, variables, or state changes made during a test, ensuring that each test runs in isolation and does not interfere with subsequent tests. This helps maintain reliability and consistency across the test suite.",
    "body": [
      "teardown()$0"
    ],
    "scope": "cfml"
  },
  "text": {
    "prefix": "text",
    "description": "Used within a migration to add one or more text columns to a database table definition. Text columns are designed for storing larger amounts of character data compared to standard string or varchar columns. This function allows you to define the column name, set a default value, and control whether the column allows null values.",
    "body": [
      "text()$0"
    ],
    "scope": "cfml"
  },
  "text(allParams)": {
    "prefix": "text",
    "description": "Used within a migration to add one or more text columns to a database table definition. Text columns are designed for storing larger amounts of character data compared to standard string or varchar columns. This function allows you to define the column name, set a default value, and control whether the column allows null values.",
    "body": [
      "text(columnNames = ${1:\"\"}, default = ${2:\"\"}, allowNull = ${3:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "textArea": {
    "prefix": "textArea",
    "description": "Builds and returns an HTML <code>&lt;textarea&gt;</code> form control for a given model object and property. It is commonly used when you need a larger text input field, such as for descriptions, comments, or notes. The function automatically binds the value of the specified property from the object to the textarea. You can also pass additional attributes like class, id, or rel to customize the generated HTML. When working with nested forms or associations, you can specify the association and position arguments to bind the field to related objects. Wheels also provides options to add labels, control label placement, prepend or append HTML around the field, and handle error display automatically.",
    "body": [
      "textArea(objectName = ${1:\"\"}, property = ${2:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "textArea(allParams)": {
    "prefix": "textArea",
    "description": "Builds and returns an HTML <code>&lt;textarea&gt;</code> form control for a given model object and property. It is commonly used when you need a larger text input field, such as for descriptions, comments, or notes. The function automatically binds the value of the specified property from the object to the textarea. You can also pass additional attributes like class, id, or rel to customize the generated HTML. When working with nested forms or associations, you can specify the association and position arguments to bind the field to related objects. Wheels also provides options to add labels, control label placement, prepend or append HTML around the field, and handle error display automatically.",
    "body": [
      "textArea(objectName = ${1:\"\"}, property = ${2:\"\"}, association = ${3:\"\"}, position = ${4:\"\"}, label = ${5:\"useDefaultLabel\"}, labelPlacement = ${6:\"around\"}, prepend = ${7:\"\"}, append = ${8:\"\"}, prependToLabel = ${9:\"\"}, appendToLabel = ${10:\"\"}, errorElement = ${11:\"span\"}, errorClass = ${12:\"field-with-errors\"}, encode = ${13:\"True\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "textAreaTag": {
    "prefix": "textAreaTag",
    "description": "Builds and returns an HTML <code>&lt;textarea&gt;</code> form control based only on the supplied field name, rather than being tied to a specific model object. It is useful when you want to generate a standalone text area not bound to an object, such as for ad-hoc forms, search boxes, or generic input fields. You can set the initial content of the textarea, add a label, and pass in additional attributes like class, id, or rel. Options are also available to control label placement, prepend or append HTML wrappers, and configure whether output should be encoded for XSS protection.",
    "body": [
      "textAreaTag(name = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "textAreaTag(allParams)": {
    "prefix": "textAreaTag",
    "description": "Builds and returns an HTML <code>&lt;textarea&gt;</code> form control based only on the supplied field name, rather than being tied to a specific model object. It is useful when you want to generate a standalone text area not bound to an object, such as for ad-hoc forms, search boxes, or generic input fields. You can set the initial content of the textarea, add a label, and pass in additional attributes like class, id, or rel. Options are also available to control label placement, prepend or append HTML wrappers, and configure whether output should be encoded for XSS protection.",
    "body": [
      "textAreaTag(name = ${1:\"\"}, content = ${2:\"\"}, label = ${3:\"\"}, labelPlacement = ${4:\"around\"}, prepend = ${5:\"\"}, append = ${6:\"\"}, prependToLabel = ${7:\"\"}, appendToLabel = ${8:\"\"}, encode = ${9:\"True\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "textField": {
    "prefix": "textField",
    "description": "Builds and returns an HTML text field form control that is bound to a model object and one of its properties. By default, it will populate the value of the field from the property on the object. You can pass additional attributes such as class, id, or rel to customize the rendered tag. When working with nested associations or hasMany relationships, you can use the association and position arguments to bind the field to related properties. Wheels also supports automatically generating and placing labels, wrapping controls with custom HTML, and marking fields with errors when validation fails. The type argument lets you adjust the input type for use with HTML5 attributes like email, tel, or url.",
    "body": [
      "textField(objectName = ${1:\"\"}, property = ${2:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "textField(allParams)": {
    "prefix": "textField",
    "description": "Builds and returns an HTML text field form control that is bound to a model object and one of its properties. By default, it will populate the value of the field from the property on the object. You can pass additional attributes such as class, id, or rel to customize the rendered tag. When working with nested associations or hasMany relationships, you can use the association and position arguments to bind the field to related properties. Wheels also supports automatically generating and placing labels, wrapping controls with custom HTML, and marking fields with errors when validation fails. The type argument lets you adjust the input type for use with HTML5 attributes like email, tel, or url.",
    "body": [
      "textFieldTag(name = ${1:\"\"}, value = ${2:\"\"}, label = ${3:\"\"}, labelPlacement = ${4:\"around\"}, prepend = ${5:\"\"}, append = ${6:\"\"}, prependToLabel = ${7:\"\"}, appendToLabel = ${8:\"\"}, type = ${9:\"text\"}, encode = ${10:\"True\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "textFieldTag": {
    "prefix": "textFieldTag",
    "description": "Builds and returns a string containing a text field form control based on the supplied name.\nNote: Pass any additional arguments like <code>class</code>, <code>rel</code>, and <code>id</code>, and the generated tag will also include those values as HTML attributes.",
    "body": [
      "textFieldTag(name = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "textFieldTag(allParams)": {
    "prefix": "textFieldTag",
    "description": "Builds and returns a string containing a text field form control based on the supplied name.\nNote: Pass any additional arguments like <code>class</code>, <code>rel</code>, and <code>id</code>, and the generated tag will also include those values as HTML attributes.",
    "body": [
      "textFieldTag(name = ${1:\"\"}, value = ${2:\"\"}, label = ${3:\"\"}, labelPlacement = ${4:\"around\"}, prepend = ${5:\"\"}, append = ${6:\"\"}, prependToLabel = ${7:\"\"}, appendToLabel = ${8:\"\"}, type = ${9:\"text\"}, encode = ${10:\"True\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "time": {
    "prefix": "time",
    "description": "Adds one or more TIME columns to a table definition in a migration. Only available in a migrator CFC.",
    "body": [
      "time()$0"
    ],
    "scope": "cfml"
  },
  "time(allParams)": {
    "prefix": "time",
    "description": "Adds one or more TIME columns to a table definition in a migration. Only available in a migrator CFC.",
    "body": [
      "time(columnNames = ${1:\"\"}, default = ${2:\"\"}, allowNull = ${3:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "timeAgoInWords": {
    "prefix": "timeAgoInWords",
    "description": "Returns a human-friendly string describing the approximate time difference between two dates (defaults to comparing against the current time).",
    "body": [
      "timeAgoInWords(fromTime = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "timeAgoInWords(allParams)": {
    "prefix": "timeAgoInWords",
    "description": "Returns a human-friendly string describing the approximate time difference between two dates (defaults to comparing against the current time).",
    "body": [
      "timeAgoInWords(fromTime = ${1:\"\"}, includeSeconds = ${2:\"\"}, toTime = ${3:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "timeSelect": {
    "prefix": "timeSelect",
    "description": "Builds and returns three select form controls for hours, minutes, and seconds, based on the supplied object name and property. It is useful when you want users to input a time in a structured way without manually typing values. You can configure it to display only specific units (such as hours and minutes), control step intervals for minutes or seconds, display in 12-hour format with AM/PM, and customize labels, error handling, and additional HTML wrapping. By default, the three selects are ordered as hour, minute, and second, but you can change this order or exclude parts completely.",
    "body": [
      "timeSelect()$0"
    ],
    "scope": "cfml"
  },
  "timeSelect(allParams)": {
    "prefix": "timeSelect",
    "description": "Builds and returns three select form controls for hours, minutes, and seconds, based on the supplied object name and property. It is useful when you want users to input a time in a structured way without manually typing values. You can configure it to display only specific units (such as hours and minutes), control step intervals for minutes or seconds, display in 12-hour format with AM/PM, and customize labels, error handling, and additional HTML wrapping. By default, the three selects are ordered as hour, minute, and second, but you can change this order or exclude parts completely.",
    "body": [
      "timeSelect(objectName = ${1:\"\"}, property = ${2:\"\"}, association = ${3:\"\"}, position = ${4:\"\"}, order = ${5:\"hour,minute,second\"}, separator = ${6:\":\"}, minuteStep = ${7:\"1\"}, secondStep = ${8:\"1\"}, includeBlank = ${9:\"\"}, label = ${10:\"\"}, labelPlacement = ${11:\"around\"}, prepend = ${12:\"\"}, append = ${13:\"\"}, prependToLabel = ${14:\"\"}, appendToLabel = ${15:\"\"}, errorElement = ${16:\"span\"}, errorClass = ${17:\"field-with-errors\"}, combine = ${18:\"\"}, twelveHour = ${19:\"\"}, encode = ${20:\"True\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "timeSelectTags": {
    "prefix": "timeSelectTags",
    "description": "Builds and returns three <code>&lt;select&gt;</code> form controls for hours, minutes, and seconds based on the supplied name. This is the tag-based version of <code>timeSelect()</code>, meaning it does not bind to a model object but instead works with raw form field names. You can control the order of the selects, limit minute and second intervals, display in 12-hour format with AM/PM, and include custom labels, error handling, and HTML wrappers.",
    "body": [
      "timeSelectTags(name = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "timeSelectTags(allParams)": {
    "prefix": "timeSelectTags",
    "description": "Builds and returns three <code>&lt;select&gt;</code> form controls for hours, minutes, and seconds based on the supplied name. This is the tag-based version of <code>timeSelect()</code>, meaning it does not bind to a model object but instead works with raw form field names. You can control the order of the selects, limit minute and second intervals, display in 12-hour format with AM/PM, and include custom labels, error handling, and HTML wrappers.",
    "body": [
      "timeSelectTags(name = ${1:\"\"}, selected = ${2:\"\"}, order = ${3:\"hour,minute,second\"}, separator = ${4:\":\"}, minuteStep = ${5:\"1\"}, secondStep = ${6:\"1\"}, includeBlank = ${7:\"\"}, label = ${8:\"\"}, labelPlacement = ${9:\"around\"}, prepend = ${10:\"\"}, append = ${11:\"\"}, prependToLabel = ${12:\"\"}, appendToLabel = ${13:\"\"}, combine = ${14:\"\"}, twelveHour = ${15:\"\"}, encode = ${16:\"True\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "timestamp": {
    "prefix": "timestamp",
    "description": "Used to add one or more <code>TIMESTAMP</code> (or <code>DATETIME</code>) columns to a table definition. It lets you specify default values, whether the column allows NULL, and even override the underlying SQL type through the columnType argument. This is especially useful when you need to track creation and update times or work with custom timestamp fields. Only available in a migrator CFC.",
    "body": [
      "timestamp()$0"
    ],
    "scope": "cfml"
  },
  "timestamp(allParams)": {
    "prefix": "timestamp",
    "description": "Used to add one or more <code>TIMESTAMP</code> (or <code>DATETIME</code>) columns to a table definition. It lets you specify default values, whether the column allows NULL, and even override the underlying SQL type through the columnType argument. This is especially useful when you need to track creation and update times or work with custom timestamp fields. Only available in a migrator CFC.",
    "body": [
      "timestamp(columnNames = ${1:\"\"}, default = ${2:\"\"}, allowNull = ${3:\"\"}, columnType = ${4:\"datetime\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "timestamps": {
    "prefix": "timestamps",
    "description": "Shortcut for adding Wheels’ convention-based automatic timestamp and soft delete columns to a table definition during migrations. Instead of defining each field manually, this function quickly sets up the standard fields that are commonly used across models to track record lifecycle and soft deletion. By default, it adds createdAt, updatedAt, and deletedAt columns with appropriate types, making your migrations more concise and consistent. Only available in a migrator CFC.",
    "body": [
      "timestamps()$0"
    ],
    "scope": "cfml"
  },
  "timeUntilInWords": {
    "prefix": "timeUntilInWords",
    "description": "Returns a human-readable string describing the approximate time difference between the current date (or another starting point you provide) and a future date. It is the inverse of <code>timeAgoInWords()</code>, focusing on how long until something happens instead of how long ago it occurred. You can optionally include seconds for more precise descriptions.",
    "body": [
      "timeUntilInWords(toTime = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "timeUntilInWords(allParams)": {
    "prefix": "timeUntilInWords",
    "description": "Returns a human-readable string describing the approximate time difference between the current date (or another starting point you provide) and a future date. It is the inverse of <code>timeAgoInWords()</code>, focusing on how long until something happens instead of how long ago it occurred. You can optionally include seconds for more precise descriptions.",
    "body": [
      "timeUntilInWords(toTime = ${1:\"\"}, includeSeconds = ${2:\"\"}, fromTime = ${3:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "titleize": {
    "prefix": "titleize",
    "description": "Converts a string so that the first letter of each word is capitalized, producing a cleaner, title-like appearance. It is useful for formatting headings, labels, or any text that should follow title case conventions.",
    "body": [
      "titleize(word = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "toggle": {
    "prefix": "toggle",
    "description": "Assigns to the property specified the opposite of the property's current boolean value.\nThrows an error if the property cannot be converted to a boolean value.\nReturns this object if save called internally is <code>false</code>.",
    "body": [
      "toggle(property = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "toggle(allParams)": {
    "prefix": "toggle",
    "description": "Assigns to the property specified the opposite of the property's current boolean value.\nThrows an error if the property cannot be converted to a boolean value.\nReturns this object if save called internally is <code>false</code>.",
    "body": [
      "toggle(property = ${1:\"\"}, save = ${2:\"True\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "truncate": {
    "prefix": "truncate",
    "description": "Shortens a given text string to a specified length and appends a replacement string (by default \"...\") at the end to indicate truncation. It is useful for displaying previews of longer text in UIs, summaries, or reports while keeping the output concise.",
    "body": [
      "truncate(text = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "truncate(allParams)": {
    "prefix": "truncate",
    "description": "Shortens a given text string to a specified length and appends a replacement string (by default \"...\") at the end to indicate truncation. It is useful for displaying previews of longer text in UIs, summaries, or reports while keeping the output concise.",
    "body": [
      "truncate(text = ${1:\"\"}, length = ${2:\"30\"}, truncateString = ${3:\"...\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "uniqueidentifier": {
    "prefix": "uniqueidentifier",
    "description": "Used to add one or more UUID (Universally Unique Identifier) columns to a table definition. These columns are useful for generating globally unique keys for records instead of relying on auto-incrementing integers. By default, the function uses newid() to populate the column with a UUID, and you can also configure whether the column allows NULL. Only available in a migrator CFC.",
    "body": [
      "uniqueidentifier()$0"
    ],
    "scope": "cfml"
  },
  "uniqueidentifier(allParams)": {
    "prefix": "uniqueidentifier",
    "description": "Used to add one or more UUID (Universally Unique Identifier) columns to a table definition. These columns are useful for generating globally unique keys for records instead of relying on auto-incrementing integers. By default, the function uses newid() to populate the column with a UUID, and you can also configure whether the column allows NULL. Only available in a migrator CFC.",
    "body": [
      "uniqueidentifier(columnNames = ${1:\"\"}, default = ${2:\"newid()\"}, allowNull = ${3:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "up": {
    "prefix": "up",
    "description": "Defines the actions to migrate your database schema forward. It is called when applying a migration and is typically paired with the <code>down()</code> function, which rolls back the migration. All schema changes, such as creating tables, adding columns, or setting up indexes, should be placed inside <code>up()</code>. Wrapping your migration code in a transaction block ensures that changes are either fully applied or rolled back in case of errors. Only available in a migration CFC.",
    "body": [
      "up()$0"
    ],
    "scope": "cfml"
  },
  "update": {
    "prefix": "update",
    "description": "Updates an existing model object with the supplied properties and saves the changes to the database. It returns true if the save was successful and false otherwise. You can pass properties directly as named arguments or as a struct. Additional options allow you to control validation, callbacks, transactions, parameterization, cache reloading, and explicit timestamp handling. This method also works seamlessly with associations, making it possible to update related objects in hasOne or hasMany relationships.",
    "body": [
      "update()$0"
    ],
    "scope": "cfml"
  },
  "update(allParams)": {
    "prefix": "update",
    "description": "Updates an existing model object with the supplied properties and saves the changes to the database. It returns true if the save was successful and false otherwise. You can pass properties directly as named arguments or as a struct. Additional options allow you to control validation, callbacks, transactions, parameterization, cache reloading, and explicit timestamp handling. This method also works seamlessly with associations, making it possible to update related objects in hasOne or hasMany relationships.",
    "body": [
      "update(properties = ${1:\"\"}, parameterize = ${2:\"True\"}, reload = ${3:\"\"}, validate = ${4:\"True\"}, transaction = ${5:\"\"}, callbacks = ${6:\"True\"}, allowExplicitTimestamps = ${7:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "updateAll": {
    "prefix": "updateAll",
    "description": "Updates all properties for the records that match the <code>where</code> argument.\nProperty names and values can be passed in either using named arguments or as a struct to the <code>properties</code> argument.\nBy default, objects will not be instantiated and therefore callbacks and validations are not invoked.\nYou can change this behavior by passing in <code>instantiate=true</code>.\nThis method returns the number of records that were updated.",
    "body": [
      "updateAll()$0"
    ],
    "scope": "cfml"
  },
  "updateAll(allParams)": {
    "prefix": "updateAll",
    "description": "Updates all properties for the records that match the <code>where</code> argument.\nProperty names and values can be passed in either using named arguments or as a struct to the <code>properties</code> argument.\nBy default, objects will not be instantiated and therefore callbacks and validations are not invoked.\nYou can change this behavior by passing in <code>instantiate=true</code>.\nThis method returns the number of records that were updated.",
    "body": [
      "updateAll(where = ${1:\"\"}, include = ${2:\"\"}, properties = ${3:\"\"}, reload = ${4:\"\"}, parameterize = ${5:\"True\"}, instantiate = ${6:\"\"}, validate = ${7:\"true\"}, transaction = ${8:\"\"}, callbacks = ${9:\"true\"}, useIndex = ${10:\"\"}, includeSoftDeletes = ${11:\"false\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "updateByKey": {
    "prefix": "updateByKey",
    "description": "Finds the object with the supplied <code>key</code> and saves it (if validation permits it) with the supplied <code>properties</code> and / or named arguments.\nProperty names and values can be passed in either using named arguments or as a struct to the <code>properties</code> argument.\nReturns <code>true</code> if the object was found and updated successfully, <code>false</code> otherwise.",
    "body": [
      "updateByKey(key = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "updateByKey(allParams)": {
    "prefix": "updateByKey",
    "description": "Finds the object with the supplied <code>key</code> and saves it (if validation permits it) with the supplied <code>properties</code> and / or named arguments.\nProperty names and values can be passed in either using named arguments or as a struct to the <code>properties</code> argument.\nReturns <code>true</code> if the object was found and updated successfully, <code>false</code> otherwise.",
    "body": [
      "updateByKey(key = ${1:\"\"}, properties = ${2:\"\"}, reload = ${3:\"\"}, validate = ${4:\"true\"}, transaction = ${5:\"\"}, callbacks = ${6:\"true\"}, includeSoftDeletes = ${7:\"false\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "updateOne": {
    "prefix": "updateOne",
    "description": "Retrieves a single model object based on the supplied arguments and updates it with the specified properties. It returns true if an object was found and updated successfully, and false if no object matched the criteria or the update failed. This method is useful when you want to update a single record that matches a certain condition without fetching multiple records. By default, objects are not instantiated, so validations and callbacks are applied only if enabled. Additional options allow control over query ordering, transactions, cache reloading, index hints, and inclusion of soft-deleted records.",
    "body": [
      "updateOne()$0"
    ],
    "scope": "cfml"
  },
  "updateOne(allParams)": {
    "prefix": "updateOne",
    "description": "Retrieves a single model object based on the supplied arguments and updates it with the specified properties. It returns true if an object was found and updated successfully, and false if no object matched the criteria or the update failed. This method is useful when you want to update a single record that matches a certain condition without fetching multiple records. By default, objects are not instantiated, so validations and callbacks are applied only if enabled. Additional options allow control over query ordering, transactions, cache reloading, index hints, and inclusion of soft-deleted records.",
    "body": [
      "updateOne(where = ${1:\"\"}, order = ${2:\"\"}, properties = ${3:\"\"}, reload = ${4:\"\"}, validate = ${5:\"true\"}, transaction = ${6:\"\"}, callbacks = ${7:\"true\"}, useIndex = ${8:\"\"}, includeSoftDeletes = ${9:\"false\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "updateProperty": {
    "prefix": "updateProperty",
    "description": "Updates a single property on a model object and saves the record immediately without running the normal validation procedures. This method is particularly useful for quickly updating flags or boolean values on existing records where full validation is not necessary. You can control transaction behavior, parameterization, and callback execution when using this method.",
    "body": [
      "updateProperty()$0"
    ],
    "scope": "cfml"
  },
  "updateProperty(allParams)": {
    "prefix": "updateProperty",
    "description": "Updates a single property on a model object and saves the record immediately without running the normal validation procedures. This method is particularly useful for quickly updating flags or boolean values on existing records where full validation is not necessary. You can control transaction behavior, parameterization, and callback execution when using this method.",
    "body": [
      "updateProperty(property = ${1:\"\"}, value = ${2:\"\"}, parameterize = ${3:\"True\"}, transaction = ${4:\"\"}, callbacks = ${5:\"true\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "updateRecord": {
    "prefix": "updateRecord",
    "description": "Allows you to update an existing record in a database table directly from within a migration CFC. This function is particularly useful when you need to modify data as part of a schema migration, such as setting default values, correcting legacy data, or updating specific records based on certain conditions. The function requires the table name and optionally allows a where clause to target specific rows. Only available in a migrator CFC.",
    "body": [
      "updateRecord(table = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "updateRecord(allParams)": {
    "prefix": "updateRecord",
    "description": "Allows you to update an existing record in a database table directly from within a migration CFC. This function is particularly useful when you need to modify data as part of a schema migration, such as setting default values, correcting legacy data, or updating specific records based on certain conditions. The function requires the table name and optionally allows a where clause to target specific rows. Only available in a migrator CFC.",
    "body": [
      "updateRecord(table = ${1:\"\"}, where = ${2:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "URLFor": {
    "prefix": "URLFor",
    "description": "Generates an internal URL based on the supplied arguments. It can create URLs using a named route, or by specifying a controller and action directly. Additional options let you include keys, query parameters, anchors, and override protocol, host, or port. By default, the function returns a relative URL, but you can configure it to return a fully qualified URL. URL parameters are automatically encoded for safety, but for HTML attribute safety, further encoding is recommended.",
    "body": [
      "URLFor()$0"
    ],
    "scope": "cfml"
  },
  "URLFor(allParams)": {
    "prefix": "URLFor",
    "description": "Generates an internal URL based on the supplied arguments. It can create URLs using a named route, or by specifying a controller and action directly. Additional options let you include keys, query parameters, anchors, and override protocol, host, or port. By default, the function returns a relative URL, but you can configure it to return a fully qualified URL. URL parameters are automatically encoded for safety, but for HTML attribute safety, further encoding is recommended.",
    "body": [
      "URLFor(route = ${1:\"\"}, controller = ${2:\"\"}, action = ${3:\"\"}, key = ${4:\"\"}, params = ${5:\"\"}, anchor = ${6:\"\"}, onlyPath = ${7:\"True\"}, host = ${8:\"\"}, protocol = ${9:\"\"}, port = ${10:\"\"}, encode = ${11:\"True\"}, $encodeForHtmlAttribute = ${12:\"\"}, $URLRewriting = ${13:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "usesLayout": {
    "prefix": "usesLayout",
    "description": "Used inside a controller's <code>config()</code> function to specify which layout template should be applied to the controller or specific actions. You can define a default layout for the entire controller, specify layouts only for certain actions, exclude specific actions from using a layout, or even provide a custom function to determine which layout to use dynamically. This allows fine-grained control over your page structure and helps maintain consistent design while accommodating exceptions.",
    "body": [
      "usesLayout(template = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "usesLayout(allParams)": {
    "prefix": "usesLayout",
    "description": "Used inside a controller's <code>config()</code> function to specify which layout template should be applied to the controller or specific actions. You can define a default layout for the entire controller, specify layouts only for certain actions, exclude specific actions from using a layout, or even provide a custom function to determine which layout to use dynamically. This allows fine-grained control over your page structure and helps maintain consistent design while accommodating exceptions.",
    "body": [
      "usesLayout(template = ${1:\"\"}, ajax = ${2:\"\"}, except = ${3:\"\"}, only = ${4:\"\"}, useDefault = ${5:\"True\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "valid": {
    "prefix": "valid",
    "description": "Runs the validation on the object and returns <code>true</code> if it passes it.\nWheels will run the validation process automatically whenever an object is saved to the database, but sometimes it's useful to be able to run this method to see if the object is valid without saving it to the database.",
    "body": [
      "valid()$0"
    ],
    "scope": "cfml"
  },
  "valid(allParams)": {
    "prefix": "valid",
    "description": "Runs the validation on the object and returns <code>true</code> if it passes it.\nWheels will run the validation process automatically whenever an object is saved to the database, but sometimes it's useful to be able to run this method to see if the object is valid without saving it to the database.",
    "body": [
      "valid(callbacks = ${1:\"true\"}, validateAssociations = ${2:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "validate": {
    "prefix": "validate",
    "description": "Used to register one or more validation methods that will be executed on a model object before it is saved to the database. This allows you to define custom validation logic beyond the built-in validations like presence or uniqueness. You can also control when the validation runs (on create, update, or both) and under what conditions using condition and unless.",
    "body": [
      "validate()$0"
    ],
    "scope": "cfml"
  },
  "validate(allParams)": {
    "prefix": "validate",
    "description": "Used to register one or more validation methods that will be executed on a model object before it is saved to the database. This allows you to define custom validation logic beyond the built-in validations like presence or uniqueness. You can also control when the validation runs (on create, update, or both) and under what conditions using condition and unless.",
    "body": [
      "validate(methods = ${1:\"\"}, condition = ${2:\"\"}, unless = ${3:\"\"}, when = ${4:\"onSave\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "validateOnCreate": {
    "prefix": "validateOnCreate",
    "description": "Registers one or more validation methods that will be executed only when a new object is being inserted into the database. This is useful for rules that should apply strictly at creation and not during updates. You can also control whether the validation runs using the condition and unless arguments.",
    "body": [
      "validateOnCreate()$0"
    ],
    "scope": "cfml"
  },
  "validateOnCreate(allParams)": {
    "prefix": "validateOnCreate",
    "description": "Registers one or more validation methods that will be executed only when a new object is being inserted into the database. This is useful for rules that should apply strictly at creation and not during updates. You can also control whether the validation runs using the condition and unless arguments.",
    "body": [
      "validateOnCreate(methods = ${1:\"\"}, condition = ${2:\"\"}, unless = ${3:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "validateOnUpdate": {
    "prefix": "validateOnUpdate",
    "description": "Registers one or more validation methods that will be executed only when an existing object is being updated in the database. This allows you to enforce rules that apply strictly to updates, without affecting the creation of new records. You can also control whether the validation runs using the condition and unless arguments.",
    "body": [
      "validateOnUpdate()$0"
    ],
    "scope": "cfml"
  },
  "validateOnUpdate(allParams)": {
    "prefix": "validateOnUpdate",
    "description": "Registers one or more validation methods that will be executed only when an existing object is being updated in the database. This allows you to enforce rules that apply strictly to updates, without affecting the creation of new records. You can also control whether the validation runs using the condition and unless arguments.",
    "body": [
      "validateOnUpdate(methods = ${1:\"\"}, condition = ${2:\"\"}, unless = ${3:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "validatesConfirmationOf": {
    "prefix": "validatesConfirmationOf",
    "description": "Validates that the value of the specified property also has an identical confirmation value.\nThis is common when having a user type in their email address a second time to confirm, confirming a password by typing it a second time, etc.\nThe confirmation value only exists temporarily and never gets saved to the database.\nBy convention, the confirmation property has to be named the same as the property with \"Confirmation\" appended at the end.\nUsing the password example, to confirm our password property, we would create a property called <code>passwordConfirmation</code>.",
    "body": [
      "validatesConfirmationOf()$0"
    ],
    "scope": "cfml"
  },
  "validatesConfirmationOf(allParams)": {
    "prefix": "validatesConfirmationOf",
    "description": "Validates that the value of the specified property also has an identical confirmation value.\nThis is common when having a user type in their email address a second time to confirm, confirming a password by typing it a second time, etc.\nThe confirmation value only exists temporarily and never gets saved to the database.\nBy convention, the confirmation property has to be named the same as the property with \"Confirmation\" appended at the end.\nUsing the password example, to confirm our password property, we would create a property called <code>passwordConfirmation</code>.",
    "body": [
      "validatesConfirmationOf(properties = ${1:\"\"}, message = ${2:\"[property] should match confirmation\"}, when = ${3:\"onSave\"}, condition = ${4:\"\"}, unless = ${5:\"\"}, caseSensitive = ${6:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "validatesExclusionOf": {
    "prefix": "validatesExclusionOf",
    "description": "Ensures that the value of a specified property is not included in a given list of disallowed values. This is commonly used to prevent reserved words, restricted entries, or disallowed values from being saved to the database. You can specify when the validation should run, allow blank values to skip validation, or conditionally run it.",
    "body": [
      "validatesExclusionOf(list = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "validatesExclusionOf(allParams)": {
    "prefix": "validatesExclusionOf",
    "description": "Ensures that the value of a specified property is not included in a given list of disallowed values. This is commonly used to prevent reserved words, restricted entries, or disallowed values from being saved to the database. You can specify when the validation should run, allow blank values to skip validation, or conditionally run it.",
    "body": [
      "validatesExclusionOf(properties = ${1:\"\"}, list = ${2:\"\"}, message = ${3:\"[property] is reserved\"}, when = ${4:\"onSave\"}, allowBlank = ${5:\"\"}, condition = ${6:\"\"}, unless = ${7:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "validatesFormatOf": {
    "prefix": "validatesFormatOf",
    "description": "Validates that the value of the specified property is formatted correctly by matching it against a regular expression using the regEx argument and / or against a built-in CFML validation type using the type argument (creditcard, date, email, etc.).",
    "body": [
      "validatesFormatOf()$0"
    ],
    "scope": "cfml"
  },
  "validatesFormatOf(allParams)": {
    "prefix": "validatesFormatOf",
    "description": "Validates that the value of the specified property is formatted correctly by matching it against a regular expression using the regEx argument and / or against a built-in CFML validation type using the type argument (creditcard, date, email, etc.).",
    "body": [
      "validatesFormatOf(properties = ${1:\"\"}, regEx = ${2:\"\"}, type = ${3:\"\"}, message = ${4:[property] is invalid}, when = ${5:onSave}, allowBlank = ${6:false}, condition = ${7:\"\"}, unless = ${8:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "validatesInclusionOf": {
    "prefix": "validatesInclusionOf",
    "description": "Ensures that a property’s value exists in a predefined list of allowed values. It is commonly used for dropdowns, radio buttons, or any scenario where only specific values are acceptable.",
    "body": [
      "validatesInclusionOf(list = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "validatesInclusionOf(allParams)": {
    "prefix": "validatesInclusionOf",
    "description": "Ensures that a property’s value exists in a predefined list of allowed values. It is commonly used for dropdowns, radio buttons, or any scenario where only specific values are acceptable.",
    "body": [
      "validatesInclusionOf(properties = ${1:\"\"}, list = ${2:\"\"}, message = ${3:\"[property] is not included in the list\"}, when = ${4:\"onSave\"}, allowBlank = ${5:\"\"}, condition = ${6:\"\"}, unless = ${7:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "validatesLengthOf": {
    "prefix": "validatesLengthOf",
    "description": "Validates that the value of the specified property matches the length requirements supplied.\nUse the <code>exactly</code>, <code>maximum</code>, <code>minimum</code> and <code>within</code> arguments to specify the length requirements.",
    "body": [
      "validatesLengthOf()$0"
    ],
    "scope": "cfml"
  },
  "validatesLengthOf(allParams)": {
    "prefix": "validatesLengthOf",
    "description": "Validates that the value of the specified property matches the length requirements supplied.\nUse the <code>exactly</code>, <code>maximum</code>, <code>minimum</code> and <code>within</code> arguments to specify the length requirements.",
    "body": [
      "validatesLengthOf(properties = ${1:\"\"}, message = ${2:\"[property] is the wrong length\"}, when = ${3:\"onSave\"}, allowBlank = ${4:\"\"}, exactly = ${5:\"\"}, maximum = ${6:\"\"}, minimum = ${7:\"\"}, within = ${8:\"\"}, condition = ${9:\"\"}, unless = ${10:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "validatesNumericalityOf": {
    "prefix": "validatesNumericalityOf",
    "description": "Ensures that a property’s value is numeric. You can also enforce additional constraints such as integer-only values, odd/even numbers, and comparison limits (greaterThan, lessThan, etc.).",
    "body": [
      "validatesNumericalityOf()$0"
    ],
    "scope": "cfml"
  },
  "validatesNumericalityOf(allParams)": {
    "prefix": "validatesNumericalityOf",
    "description": "Ensures that a property’s value is numeric. You can also enforce additional constraints such as integer-only values, odd/even numbers, and comparison limits (greaterThan, lessThan, etc.).",
    "body": [
      "validatesNumericalityOf(properties = ${1:\"\"}, message = ${2:\"[property] is not a number\"}, when = ${3:\"onSave\"}, allowBlank = ${4:\"\"}, onlyInteger = ${5:\"\"}, condition = ${6:\"\"}, unless = ${7:\"\"}, odd = ${8:\"\"}, even = ${9:\"\"}, greaterThan = ${10:\"\"}, greaterThanOrEqualTo = ${11:\"\"}, equalTo = ${12:\"\"}, lessThan = ${13:\"\"}, lessThanOrEqualTo = ${14:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "validatesPresenceOf": {
    "prefix": "validatesPresenceOf",
    "description": "Ensures that the specified property (or properties) exists and is not blank. It is commonly used to enforce required fields before saving an object to the database.",
    "body": [
      "validatesPresenceOf()$0"
    ],
    "scope": "cfml"
  },
  "validatesPresenceOf(allParams)": {
    "prefix": "validatesPresenceOf",
    "description": "Ensures that the specified property (or properties) exists and is not blank. It is commonly used to enforce required fields before saving an object to the database.",
    "body": [
      "validatesPresenceOf(properties = ${1:\"\"}, message = ${2:\"[property] can't be empty\"}, when = ${3:\"onSave\"}, condition = ${4:\"\"}, unless = ${5:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "validatesUniquenessOf": {
    "prefix": "validatesUniquenessOf",
    "description": "Validates that the value of the specified property is unique in the database table.\nUseful for ensuring that two users can't sign up to a website with identical usernames for example.\nWhen a new record is created, a check is made to make sure that no record already exists in the database table with the given value for the specified property.\nWhen the record is updated, the same check is made but disregarding the record itself.",
    "body": [
      "validatesUniquenessOf()$0"
    ],
    "scope": "cfml"
  },
  "validatesUniquenessOf(allParams)": {
    "prefix": "validatesUniquenessOf",
    "description": "Validates that the value of the specified property is unique in the database table.\nUseful for ensuring that two users can't sign up to a website with identical usernames for example.\nWhen a new record is created, a check is made to make sure that no record already exists in the database table with the given value for the specified property.\nWhen the record is updated, the same check is made but disregarding the record itself.",
    "body": [
      "validatesUniquenessOf(properties = ${1:\"\"}, message = ${2:\"[property] has already been taken\"}, when = ${3:\"onSave\"}, allowBlank = ${4:\"\"}, scope = ${5:\"\"}, condition = ${6:\"\"}, unless = ${7:\"\"}, includeSoftDeletes = ${8:\"true\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "validationTypeForProperty": {
    "prefix": "validationTypeForProperty",
    "description": "Returns the type of validation that Wheels would apply for a given property. This is useful if you want to dynamically inspect a model's property type or apply logic based on the property's expected format.",
    "body": [
      "validationTypeForProperty(property = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "verificationChain": {
    "prefix": "verificationChain",
    "description": "Returns an array of all verifications (filters, before-actions, or checks) that are configured for the current controller, in the order they will be executed. This allows you to inspect, modify, or reorder the verifications dynamically.",
    "body": [
      "verificationChain()$0"
    ],
    "scope": "cfml"
  },
  "verifies": {
    "prefix": "verifies",
    "description": "Instructs a Wheels controller to check that certain criteria are met before executing an action. This is useful for enforcing request types, required parameters, session/cookie values, or custom verifications. Note that all undeclared arguments will be passed to <code>redirectTo()</code> call if a <code>handler</code> is not specified.",
    "body": [
      "verifies()$0"
    ],
    "scope": "cfml"
  },
  "verifies(allParams)": {
    "prefix": "verifies",
    "description": "Instructs a Wheels controller to check that certain criteria are met before executing an action. This is useful for enforcing request types, required parameters, session/cookie values, or custom verifications. Note that all undeclared arguments will be passed to <code>redirectTo()</code> call if a <code>handler</code> is not specified.",
    "body": [
      "verifies(only = ${1:\"\"}, except = ${2:\"\"}, post = ${3:\"\"}, get = ${4:\"\"}, ajax = ${5:\"\"}, cookie = ${6:\"\"}, session = ${7:\"\"}, params = ${8:\"\"}, handler = ${9:\"\"}, cookieTypes = ${10:\"\"}, sessionTypes = ${11:\"\"}, paramsTypes = ${12:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "wildcard": {
    "prefix": "wildcard",
    "description": "Automatically generates dynamic routes for your controllers using placeholders like [controller], [action], and optionally [key] or [format]. This allows you to quickly map standard URL patterns to controllers and actions without explicitly defining every route.",
    "body": [
      "wildcard()$0"
    ],
    "scope": "cfml"
  },
  "wildcard(allParams)": {
    "prefix": "wildcard",
    "description": "Automatically generates dynamic routes for your controllers using placeholders like [controller], [action], and optionally [key] or [format]. This allows you to quickly map standard URL patterns to controllers and actions without explicitly defining every route.",
    "body": [
      "wildcard(method = ${1:\"get\"}, action = ${2:\"index\"}, mapKey = ${3:\"\"}, mapFormat = ${4:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "wordTruncate": {
    "prefix": "wordTruncate",
    "description": "Truncates text to the specified length of words and replaces the remaining characters with the specified truncate string (which defaults to \"...\").",
    "body": [
      "wordTruncate(text = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "wordTruncate(allParams)": {
    "prefix": "wordTruncate",
    "description": "Truncates text to the specified length of words and replaces the remaining characters with the specified truncate string (which defaults to \"...\").",
    "body": [
      "wordTruncate(text = ${1:\"\"}, length = ${2:5}, truncateString = ${3:...})",
      "$0"
    ],
    "scope": "cfml"
  },
  "yearSelectTag": {
    "prefix": "yearSelectTag",
    "description": "Builds and returns a string containing a <code>select</code> form control for a range of years based on the supplied name.",
    "body": [
      "yearSelectTag(name = ${1:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "yearSelectTag(allParams)": {
    "prefix": "yearSelectTag",
    "description": "Builds and returns a string containing a <code>select</code> form control for a range of years based on the supplied name.",
    "body": [
      "yearSelectTag(name = ${1:\"\"}, selected = ${2:\"\"}, startYear = ${3:\"2018\"}, endYear = ${4:\"2028\"}, includeBlank = ${5:\"\"}, label = ${6:\"\"}, labelPlacement = ${7:\"around\"}, prepend = ${8:\"\"}, append = ${9:\"\"}, prependToLabel = ${10:\"\"}, appendToLabel = ${11:\"\"}, encode = ${12:\"True\"}, $now = ${13:\"\"})",
      "$0"
    ],
    "scope": "cfml"
  },
  "wheels-controller-template": {
    "prefix": "wcontroller",
    "description": "Complete Wheels controller template with CRUD actions",
    "body": [
      "// This template now loads from /templates/controller.cfc file",
      "// Edit the template file directly for easier maintenance"
    ],
    "scope": "cfml"
  },
  "wheels-model-template": {
    "prefix": "wmodel",
    "description": "Complete Wheels model template with common patterns",
    "body": [
      "// This template now loads from /templates/model.cfc file",
      "// Edit the template file directly for easier maintenance"
    ],
    "scope": "cfml"
  },
  "wheels-validation-set": {
    "prefix": "wvalidation",
    "description": "Common Wheels validation patterns",
    "body": [
      "// Basic validations",
      "validatesPresenceOf(\"${1:name,email}\");",
      "validatesUniquenessOf(\"${2:email}\");",
      "validatesLengthOf(property=\"${3:name}\", minimum=${4:2}, maximum=${5:50});",
      "",
      "// Format validations",
      "validatesFormatOf(property=\"${2:email}\", regEx=\"^[\\w\\.-]+@[\\w\\.-]+\\.\\w+$\");",
      "validatesFormatOf(property=\"${6:phone}\", regEx=\"^[\\d\\-\\(\\)\\+\\s]+$\");",
      "",
      "// Conditional validations",
      "validatesPresenceOf(property=\"${7:password}\", condition=\"this.isNew()\");",
      "validatesConfirmationOf(\"${7:password}\");",
      "",
      "$0"
    ],
    "scope": "cfml"
  },
  "wheels-association-set": {
    "prefix": "wassociations",
    "description": "Common Wheels association patterns",
    "body": [
      "// One-to-many relationships",
      "hasMany(\"${1:orders}\", dependent=\"${2:delete}\");",
      "hasMany(\"${3:comments}\", class=\"${4:Comment}\", foreignKey=\"${5:userId}\");",
      "",
      "// Many-to-one relationships",
      "belongsTo(\"${6:category}\");",
      "belongsTo(\"${7:user}\", class=\"${8:User}\", foreignKey=\"${9:createdBy}\");",
      "",
      "// One-to-one relationships",
      "hasOne(\"${10:profile}\");",
      "hasOne(\"${11:account}\", dependent=\"${12:delete}\");",
      "",
      "// Many-to-many relationships",
      "hasMany(\"${13:tags}\", through=\"${14:taggings}\");",
      "",
      "$0"
    ],
    "scope": "cfml"
  },
  "wheels-finder-methods": {
    "prefix": "wfinders",
    "description": "Custom Wheels finder method examples",
    "body": [
      "// Basic finders",
      "function findActive() {",
      "\treturn findAll(where=\"active = 1\", order=\"${1:name} ASC\");",
      "}",
      "",
      "function findByName(required string name) {",
      "\treturn findOne(where=\"name = '#arguments.name#'\");",
      "}",
      "",
      "function findRecent(numeric limit = 10) {",
      "\treturn findAll(",
      "\t\torder=\"createdAt DESC\",",
      "\t\tmaxRows=arguments.limit",
      "\t);",
      "}",
      "",
      "// Complex finders with joins",
      "function findWithCategory() {",
      "\treturn findAll(",
      "\t\tinclude=\"${2:category}\",",
      "\t\torder=\"categories.name ASC, ${1:name} ASC\"",
      "\t);",
      "}",
      "",
      "$0"
    ],
    "scope": "cfml"
  }
}